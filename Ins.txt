
Qns no 1:
Situation - 
You have millions of records(Strings) and user is typing "abc" in search box . 
Your task is to display strings from records in the sequence. 
e.g
String in the record contain "abc" starting should appear first, 
then string which has "abc" in the second, 
should apprear later as below. 

String - fabcsdf,asdfabc,dfadsfsdfabc,abckdf,ddfabc... 

Displays suggestion like.... 
abckdf 
fabcsdf 
ddfabc 
asdfabc 
dfadsfsdfabc 



Qns 2: - Which data structure you would use to store this ? 
And how will you implement to get this(shorted) result


qns 3: difference between sealed class and static class?


qns 4: what is inharitance, type of inharitance in C# and why multiple inheritance is not possible in c#?


qns 5: what is interface, why interface member public by default?


qns 6: difference between interface and abstract class?


qns 7: size of object of class A{} and size of int c#, and maximum size of obj?
ans 
.NET limits any object to max 2 GB even on 64 bit platforms. You can create your own data type, 
that uses multiple objects to store more data, thus getting around the 2 GB limit of a single object. 
For instance a List<float[]> would allow you to store more than 2 GB, but you would have to write the 
necessary plumbing code to make it behave similar to a single, large array.


qns 8: difference bewteen html attribute and dom properties?
ans: you can change dom property value but you can change attribute value


For instance, this HTML element:
<input type="text" value="Name:">  has 2 attributes (type and value).

theInput.value // returns "John"

whereas:
theInput.getAttribute('value') // returns "Name:"

The value property reflects the current text-content inside the input box, whereas the value attribute 
contains the initial text-content of the value attribute from the HTML source code.

So if you want to know what's currently inside the text-box, read the property. If you, 
however, want to know what the initial value of the text-box was, read the attribute. 
Or you can use the defaultValue property, which is a pure reflection of the value attribute:

theInput.value                 // returns "John"
theInput.getAttribute('value') // returns "Name:"
theInput.defaultValue          // returns "Name:"




qns 9:  what is ref parameter, out parameter, default parameter and params keywords?


qns 10: what is a delegate and why we used delegate?
ans: 
In Multicasting, Delegates can be combined and when you call a delegate, a whole list of methods is called.
All methods are called in FIFO (First in First Out) order.
+ or += Operator is used for adding methods to delegates.
– or -= Operator is used for removing methods from the delegates list

qns 11: type casting and its all possible scenrios?


qns 12: what is polymorphism and its type?


qns 13: difference between value type and ref type?

Value type: Holds some value not memory addresses
--------------------------------------------------
Example: Struct
Storage:
TL;DR: A variable's value is stored wherever it is decleared. Local variables live on the stack for example, but when declared inside a class as a member 
it lives on the heap tightly coupled with the class it is declared in. 
Longer: Thus value types are stored wherever they are declared. E.g.: an int's value inside a function as a local variable 
would be stored on the stack, whilst an in int's value declared as member in a class would be stored on the heap with the 
class it is declared in. A value type on a class has a lifetype that is exactly the same as the class it is declared in, 
requiring almost no work by the garbage collector. It's more complicated though, i'd refer to @JonSkeet's book "C# In Depth" 
or his article "Memory in .NET" for a more concise explenation.

Advantages:
A value type does not need extra garbage collection. 
It gets garbage collected together with the instance it lives in. 
Local variables in methods get cleaned up upon method leave.

Drawbacks:
When large set of values are passed to a method the receiving variable actually copies 
so there are two redundant values in memory.

As classes are missed out.it losses all the oop benifits

Reference type: Holds a memory address of a value not value
--------------------------------------------------
Example: Class
Storage: Stored on heap
Advantages:
When you pass a reference variable to a method and it changes it indeed changes the original value whereas in value types a copy of the given variable is taken and 
that's value is changed.
When the size of variable is bigger reference type is good
As classes come as a reference type variables, they give reusability, thus benefitting Object-oriented programming

Drawbacks:
More work referencing when allocating and dereferences when reading the value.extra overload for garbage collector

1.What are Value Types ? Give example
Variables that store data are called value types. Value types are stored on stack.
They contain the actual values. eg-int, enum, structs.  
2.What are Reference Types? Give Example.
Variables that store reference to actual data are called Reference types.Reference types
stored on heap but contain the address on heap.
eg-class,interface,delegate,string,object,Array

3.Difference between value type and reference types ?
    
Value Type
They are stored on stack
Contains actual value
Cannot contain null values. However this can be achieved by nullable types
Value type is popped on its own from stack when they go out of scope.
Memory is allocated at compile time


Reference Type
They are stored on heap
Contains reference to a value
Can contain null values.
Required garbage collector to free memory.
Memory is allocated at run time
   
4.Diff b/w stack and heap
    
Stack
Values are stored on one another like a stack.
Used for value type

The stack is always reserved in a LIFO (last in first out) order; 
the most recently reserved block is always the next block to be freed. 
This makes it really simple to keep track of the stack; 
freeing a block from the stack is nothing more than adjusting one pointer.

Heap
Values are stored in random order.like dumped into a huge space
Used for reference types

Element of the heap have no dependencies with each other and can always be accessed randomly at any time. 
You can allocate a block at any time and free it at any time.

The heap is memory set aside for dynamic allocation. Unlike the stack, 
there's no enforced pattern to the allocation and deallocation of blocks from the heap; 
you can allocate a block at any time and free it at any time. This makes it much more complex 
to keep track of which parts of the heap are allocated or free at any given time; 
there are many custom heap allocators available to tune heap performance for different usage patterns


Stack and a Heap ?
---------------------
Stack is used for static memory allocation and 
Heap is used  for dynamic memory allocation, both stored in the computer's RAM .



qns 14: what is DI and its advantage (how di makes unit testing easy)?
ans: 


qns 15: different type of constructor and its usage
ans:
Constructor(s) in a class is/are special methods which get called automatically 
when an object of a class is created. 
Constructors are specially used to initialize data members.

There are different types of constructors you can write in a class -
1. Default Constructor
2. Parameterized Constructor
3. Copy Constructor
4. Static Constructor
 

Default Constructor
When you do not declare any constructor, 
the class will call its default constructor which has a default public access modifier. 
The default constructor is a parameter less constructor which will be called by a class object.

Let's see an example of a Default Constructor -

public class Person
{
    private int m_PersonID;
    private string m_FirstName, m_LastName, m_City;
    public Person()
    {
        m_PersonID = 19929;
        m_FirstName = "No First Name";
        m_LastName = "No Last Name";
        m_City = "No City";
    }
}
This default constructor will be executed whenever the class is initialized – Person p = new Person();

Note: If the class is abstract, then the accessibility of the default constructor is protected. 
Otherwise, the accessibility for the default constructor is public

Parameterized constructors
Now let’s see parameterized constructors. You can also call it as constructor overloading. 
Default constructors always initialize the objects with the same values. In case you want to initialize the class with different values,
 you can use Parameterized constructors.

public class Person
{
    private int m_PersonID;
    private string m_FirstName, m_LastName, m_City;
    public Person()
    {
        m_PersonID = 19929;
        m_FirstName = "No First Name";
        m_LastName = "No Last Name";
        m_City = "No City";
    }
    public Person(string firstName,string lastName)
    {
        m_FirstName = firstName;
        m_LastName = lastName;
    }
}
To invoke the parameterized constructor, use this Person p1 = new Person(“DotNet”, “Curry”);

 

Copy Constructor
Now let's see an example of Copy Constructor. 
Copy constructor is the parameterized constructor which takes a parameter of the same type. 
It allows you to initialize a new object with the existing object values.

public class Person
{
    private int m_PersonID;
    private string m_FirstName, m_LastName, m_City;
    public Person()
    {
        m_PersonID = 19929;
        m_FirstName = "No First Name";
        m_LastName = "No Last Name";
        m_City = "No City";
    }
    public Person(string firstName,string lastName)
    {
        m_FirstName = firstName;
        m_LastName = lastName;
    }
     
    //copy constructor
    public Person(Person person)
    {
        m_PersonID = person.m_PersonID;
        m_FirstName = person.m_FirstName;
        m_LastName = person.m_LastName;
        m_City = person.m_City;
    }
}
Here’s an example:

// Instance constructor.
Person p1 = new Person(1, "DotNet", "Curry", "Pune");
 
// Copy Constructor
Person p2 = new Person(p1);
  
Static Constructors
Static constructor is used to initialize the static data members of the class.
Static constructor is only called once while creation of the first instance of the class. 
After that, no instance of a class will call the static constructor. 
You can also use static constructor to execute some code of the class which must be executed only once.

public class Person
{
    static Person()
    {
        //Static Members
    }
}
In inheritance, the calling of the constructor starts from the parent class.

Let's see how to use these constructors -

static void Main(string[] args)
{
    Person p1 = new Person();//This will call Default Constructor
    Person p2 = new Person("Pravin", "D");//This will call two parameterized Constructor
    Person p3 = new Person(p2);//This will call Copy Constructor
}

It is worth mentioning that you can also create a private constructor, 
which is  generally used in classes that contain static members only.
If you create a private constructor, you cannot create an instance of a class.

class Person
{
    // Private Constructor:
    private Person() { } 
}


qns 16: what is the default value of int,char,float,decimal, double in c#
ans: int,float,double,decimal =0 and char ='\0'




qns 17: why interface member are public by default
ans: becz you cant change asscess modifier in inharitance and again if we have proptected or
protected internal in interface declaration then we need to have same access modifier in derived class
that we do not need, anyone can directly provide defination for interface methods




Qns:18-How to call a method having 5 default parameters by providing only any 2 parameters, ignore the sequence.
ans: using named argument



Qns:19- Method signature
Return type is not part of the method signature in C#. 
Only the method name and its parameters types (but not the parameter names) are part of the signature. 
You cannot, for example, have these two methods:

int DoSomething(int a, int b);
string DoSomething(int a, int b);
To be clear: Methods cannot be overloaded based on their return type. 

They must have a unique name, unique parameter types, 
or pass their arguments differently (e.g. using out or ref).

Edit: To answer your original question, the method signature for your method is:

DoSomething(int, int)
Note that this all applies to normal methods. 
If you're talking about delegates, 
(Short version: return type is the part of the signature for a delegate).



Qns 20:
Finalizers / Destructor
Finalizers are used to destruct instances of classes.
Remarks
Finalizers cannot be defined in structs. They are only used with classes.
A class can only have one finalizer.
Finalizers cannot be inherited or overloaded.
Finalizers cannot be called. They are invoked automatically.
A finalizer does not take modifiers or have parameters.

For example, the following is a declaration of a finalizer for the Car class.


class Car
{
    ~Car()  // destructor
    {
        // cleanup statements...
    }
}




Qns 21: Differences Between Parameters and Arguments?
ans:
method defines a parameter, and the calling code passes an argument to that parameter. 
You can think of the parameter as a parking space and the argument as an automobile. 
Just as different automobiles can park in a parking space at different times, 
the calling code can pass a different argument to the same parameter every time that it calls the procedure.

Note:
For each parameter, 
you specify a name,
a data type, 
and a passing mechanism (ByVal or ByRef). 
You can also indicate that a parameter is optional. 
This means that the calling code does not have to pass a value for it.



Qns 22: Anonymous Functions?
ans: An anonymous function is an "inline" statement or expression that can be used wherever a delegate type is expected. 

class Test
{
    delegate void TestDelegate(string s);
    static void M(string s)
    {
        Console.WriteLine(s);
    }

    static void Main(string[] args)
    {
        // Original delegate syntax required 
        // initialization with a named method.
        TestDelegate testDelA = new TestDelegate(M);

        // C# 2.0: A delegate can be initialized with
        // inline code, called an "anonymous method." This
        // method takes a string as an input parameter.
        TestDelegate testDelB = delegate(string s) { Console.WriteLine(s); };

        // C# 3.0. A delegate can be initialized with
        // a lambda expression. The lambda also takes a string
        // as an input parameter (x). The type of x is inferred by the compiler.
        TestDelegate testDelC = (x) => { Console.WriteLine(x); };

        // Invoke the delegates.
        testDelA("Hello. My name is M and I write lines.");
        testDelB("That's nothing. I'm anonymous and ");
        testDelC("I'm a famous author.");

        // Keep console window open in debug mode.
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
    }
}
/* Output:
    Hello. My name is M and I write lines.
    That's nothing. I'm anonymous and
    I'm a famous author.
    Press any key to exit.
 */







qns 23:Generic Methods 
ans: A generic method is a method that is declared with type parameters, as follows:

static void Swap<T>(ref T lhs, ref T rhs)
{
    T temp;
    temp = lhs;
    lhs = rhs;
    rhs = temp;
}
The following code example shows one way to call the method by using int for the type argument:

public static void TestSwap()
{
    int a = 1;
    int b = 2;

    Swap<int>(ref a, ref b);
    System.Console.WriteLine(a + " " + b);
}
You can also omit the type argument and the compiler will infer it. The following call to Swap is equivalent to the previous call:

Swap(ref a, ref b);

If you define a generic method that takes the same type parameters as the containing class, 
the compiler generates warning CS0693 because within the method scope, the argument supplied 
for the inner T hides the argument supplied for the outer T. If you require the flexibility 
of calling a generic class method with type arguments other than the ones provided when the 
class was instantiated, consider providing another identifier for the type parameter of the method, 
as shown in GenericList2<T> in the following example.


class GenericList<T>
{
    // CS0693
    void SampleMethod<T>() { }
}

class GenericList2<T>
{
    //No warning
    void SampleMethod<U>() { }
}





Qns 24: Generic Delegates 
Ans:
A delegate can define its own type parameters. 
Code that references the generic delegate can specify the type argument 
to create a closed constructed type, just like when instantiating a generic class 
or calling a generic method, as shown in the following example:

public delegate void Del<T>(T item);
public static void Notify(int i) { }
Del<int> m1 = new Del<int>(Notify);




Qns 25: Generic Type Parameters 
ans:
In a generic type or method definition, 
a type parameters is a placeholder for a specific type that a client specifies 
when they instantiate a variable of the generic type. 
A generic class, such as GenericList<T> listed in Introduction to Generics, 
cannot be used as-is because it is not really a type; 
it is more like a blueprint for a type. 
To use GenericList<T>, client code must declare and instantiate a constructed type 
by specifying a type argument inside the angle brackets. 
The type argument for this particular class can be any type recognized by the compiler. 
Any number of constructed type instances can be created, each one using a different type argument, as follows:


GenericList<float> list1 = new GenericList<float>();
GenericList<ExampleClass> list2 = new GenericList<ExampleClass>();
GenericList<ExampleStruct> list3 = new GenericList<ExampleStruct>();
In each of these instances of GenericList<T>, every occurrence of T in the class will be substituted 
at run time with the type argument. By means of this substitution, we have created three separate type-safe 
and efficient objects using a single class definition. For more information on how this substitution is 
performed by the CLR, see Generics in the Run Time.

Type Parameter Naming Guidelines
Do name generic type parameters with descriptive names, unless a single letter name is completely self 
explanatory and a descriptive name would not add value.

public interface ISessionChannel<TSession> { /*...*/ }
public delegate  TOutput Converter<TInput, TOutput>(TInput from);
public class List<T> { /*...*/ }

Consider using T as the type parameter name for types with one single letter type parameter.
public int IComparer<T>() { return 0; }
public delegate bool Predicate<T>(T item);
public struct Nullable<T> where T : struct { /*...*/ }

Do prefix descriptive type parameter names with "T".
public interface ISessionChannel<TSession>
{
    TSession Session { get; }
}
Consider indicating constraints placed on a type parameter in the name of parameter. 
For example, a parameter constrained to ISession may be called TSession.





Q 26: what is serialization?
ans: serialization is the process of translating data structures
into a format that can be stored or transmitted and reconstructed later

Serialization is the process of converting an object into a stream of bytes 
in order to store the object or transmit it, a database, or a file. 
and recreate it when needed. 
The reverse process is called deserialization.








Q 27: What does the Web.Config file do in the views folder of a MVC project

The web.config file exists in the Views folders to prevent access to your views by 
any means other than your controller. In the MVC design pattern, controllers are supposed 
to route requests and return a rendered view to the calling client.

In other words, your view at www.mydomain.com/MySuperController/AwesomeAction1/SweetPage.aspx 
should not be directly accessible.

If you peek at the web.config file it actually registers the HttpNotFoundHandler to all 
paths and verbs:

<add path="*" verb="*" type="System.Web.HttpNotFoundHandler"/>
Or, in IIS 7 it might look like

<add name="BlockViewHandler" path="*.aspx" verb="*" 
    preCondition="integratedMode" type="System.Web.HttpNotFoundHandler"/>




Qns 28: how to install window service using cmd prompt
ans: start up the command prompt (CMD) with administrator rights.
Type c:\windows\microsoft.net\framework\v4.0.30319\installutil.exe 
[your windows service path to exe]
Press return and thats that!








Q 29 : Url.Content and @Url.Action

Url.Content is used when you wish to resolve a URL for any file or resource on your site and you would pass it the relative path:

@Url.Content("~/path/file.htm")

Url.Action is used to resolve an action from a controller such as:
@Url.Action("ActionName", "ControllerName", new { variable = value })






Q 30: What is REST?

Representational State Transfer is an architectural style that defines a set of constraints to be used for creating web services

Representational State Transfer (REST) is an architectural style that defines a set of constraints and 
properties based on HTTP. Web Services that conform to the REST architectural style, or RESTful web services, 
provide interoperability between computer systems on the Internet.

One of the most popular types of API is REST or, as they’re sometimes known, RESTful APIs. 
REST or RESTful APIs were designed to take advantage of existing protocols. 
While REST - or Representational State Transfer - can be used over nearly any protocol, 
when used for web APIs it typically takes advantage of HTTP. 
This means that developers have no need to install additional software or libraries when creating a REST API.

Stateless: REST APIs are stateless, meaning that calls can be made independently of one another, and each 
call contains all of the data necessary to complete itself successfully.

Cache: Because a stateless API can increase request overhead by handling large loads of incoming and outbound calls, 
a REST API should be designed to encourage the storage of cacheable data.

https://searchmicroservices.techtarget.com/definition/REST-representational-state-transfer



Q 31: What is the difference between keep() and peek()?

MSDN says:

keep(): marks the specified key in the dictionary for retention.
peek(): returns an object that contains the element that is
associated with the specified key, without marking the key for
deletion.




Q 32:
readonly, constant and Static ReadOnly:

Constants:

1. Constants can be assigned values only at the time of declaration
2. Constant variables have to be accessed using "Classname.VariableName"
3. Constants are known at compile time

Read Only:

1. Read only variables can be assigned values either at runtime 
or at the time of instance initialization via constructor
(
we can assign value during declaration,  
under static constructor, 
under parameter less constructor
)
2. Read only variables have to be accessed using the "InstanceName.VariableName"
3. Read only variables are known at run time.

Static ReadOnly: 

A Static Readonly type variable's value can be assigned at runtime or 
assigned at compile time and changed at runtime.
But this variable's value can only be changed in the static constructor. 
And cannot be changed further.
It can change only once at runtime. Let's understand it practically.


At a very high level, as per MSDN
Constants are immutable values which are known at compile time and 
do not change their values for the life of the program. 

Readonly variables are also immutable values which are known 
at run time and do not change their values for the life of the program.






Q 33: What is the difference between a field and a property?


Properties expose fields. Fields should (almost always) be kept private to a class and accessed 
via get and set properties. Properties provide a level of abstraction allowing you to change 
the fields while not affecting the external way they are accessed by the things that use your class.

public class MyClass
{
    // this is a field.  It is private to your class and stores the actual data.
    private string _myField;

    // this is a property. When accessed it uses the underlying field,
    // but only exposes the contract, which will not be affected by the underlying field
    public string MyProperty
    {
        get
        {
            return _myField;
        }
        set
        {
            _myField = value;
        }
    }

    // This is an AutoProperty (C# 3.0 and higher) - which is a shorthand syntax
    // used to generate a private field for you
    public int AnotherProperty{get;set;} 
}
@Kent points out that Properties are not required to encapsulate fields, 
they could do a calculation on other fields, 
or serve other purposes.

@GSS points out that you can also do other logic, such as validation, 
when a property is accessed, another useful feature.


In C# language one of the common interview questions is, "What is the difference b/w Field and Property in C#?".
In this blog I will explain some differences between field and property in C#.
public class Person   
{  
    private int Id; //Field  
    public int User_ID   
  {   
    //Property  
        get   
        {  
            return Id;  
        }  
        set   
        {  
            Id = value;  
        }  
    }  
}   
Object orientated programming principles say that the internal workings of a class should 
be hidden from the outside world. If you expose a field you're in essence exposing the 
internal implementation of the class. So we wrap the field using the property to hide 
the internal  working of the class.

We can see that in the above code section we define property as public and filed as private, 
so user can only access the property but internally we are using the field, such that provides 
a level of abstraction  and hides the field from user access.

Another  important difference is that interfaces can have properties but not fields.

Using property we can throw an event but this is not possible in field.
Example
public class Person  
{  
    private int Id; //Field  
    public int User_ID  
  { //Property  
        get   
        {  
            return Id;  
        }  
        set   
        {  
            valueChanged();  
            Id = value;  
        }  
    }  
    public void valueChanged()   
    {  
        //Write Code  
    }  
}  













Q 34: lock keyword:
The lock keyword ensures that one thread does not enter a critical section of code 
while another thread is in the critical section. If another thread tries to enter a 
locked code, it will wait, block, until the object is released. The lock keyword 
calls Enter at the start of the block and Exit at the end of the block.




Q 35: Design Patterns
ans:
Creational Patterns
  Abstract Factory	Creates an instance of several families of classes
  Builder	        Separates object construction from its representation
  Factory Method	Creates an instance of several derived classes
  Prototype	        A fully initialized instance to be copied or cloned
  Singleton	        A class of which only a single instance can exist

Structural Patterns
  Adapter	Match interfaces of different classes
  Bridge	Separates an object’s interface from its implementation
  Composite	A tree structure of simple and composite objects
  Decorator	Add responsibilities to objects dynamically
  Facade	A single class that represents an entire subsystem
  Flyweight	A fine-grained instance used for efficient sharing
  Proxy	        An object representing another object

Behavioral Patterns
  Chain of Resp.	A way of passing a request between a chain of objects
  Command	        Encapsulate a command request as an object
  Interpreter	        A way to include language elements in a program
  Iterator	        Sequentially access the elements of a collection
  Mediator	        Defines simplified communication between classes
  Memento	        Capture and restore an object's internal state
  Observer	        A way of notifying change to a number of classes
  State	                Alter an object's behavior when its state changes
  Strategy	        Encapsulates an algorithm inside a class
  Template Method	Defer the exact steps of an algorithm to a subclass
  Visitor	        Defines a new operation to a class without change

What is Singleton Design Pattern?

Ensures a class has only one instance and provides a global point of access to it.
A singleton is a class that only allows a single instance of itself to be created, and usually gives simple access to that instance.
Most commonly, singletons don't allow any parameters to be specified when creating the instance, since a second request of an instance with a different parameter could be problematic! (If the same instance should be accessed for all requests with the same parameter then the factory pattern is more appropriate.)
There are various ways to implement the Singleton Pattern in C#. The following are the common characteristics of a Singleton Pattern.
A single constructor, that is private and parameterless.
The class is sealed.
A static variable that holds a reference to the single created instance, if any.
A public static means of getting the reference to the single created instance, creating one if necessary.

Advantages

The advantages of a Singleton Pattern are:
Singleton pattern can be implemented interfaces.
It can be also inherit from other classes.
It can be lazy loaded.
It has Static Initialization.
It can be extended into a factory pattern.
It helps to hide dependencies.
It provides a single point of access to a particular instance, so it is easy to maintain.

Disadvantages
The disadvantages of a Singleton Pattern are:
Unit testing is more difficult (because it introduces a global state into an application).
This pattern reduces the potential for parallelism within a program, 
because to access the singleton in a multi-threaded system, an object must be serialized (by locking).

using System;

public class Singleton
{
   private static Singleton instance;

   private Singleton() {}

   public static Singleton Instance
   {
      get 
      {
         if (instance == null)
         {
            instance = new Singleton();
         }
         return instance;
      }
   }
}

Static Initialization 

public sealed class Singleton
{
   private static readonly Singleton instance = new Singleton();
   
   private Singleton(){}

   public static Singleton Instance
   {
      get 
      {
         return instance; 
      }
   }
}
 
For multi-threaded Singleton environment:
 
using System;

public sealed class Singleton
{
   private static volatile Singleton instance;
   private static object syncRoot = new Object();

   private Singleton() {}

   public static Singleton Instance
   {
      get 
      {
         if (instance == null) 
         {
            lock (syncRoot) 
            {
               if (instance == null) 
                  instance = new Singleton();
            }
         }

         return instance;
      }
   }
}

thread-safe without using locks

public sealed class Singleton
{
    private static readonly Singleton instance = new Singleton();

    // Explicit static constructor to tell C# compiler
    // not to mark type as beforefieldinit
    static Singleton()
    {
    }

    private Singleton()
    {
    }

    public static Singleton Instance
    {
        get
        {
            return instance;
        }
    }
}


What is Factory Design Pattern?

In Factory pattern, we create object without exposing the creation logic. 
In this pattern, an interface is used for creating an object, but let subclass 
decide which class to instantiate. The creation of object is done when it is required. 
The Factory method allows a class later instantiation to subclasses.

Where to Use?
It would be tedious when the client needs to specify the class name while creating the objects. 
So, to resolve this problem, we can use Factory pattern. 
It provides the client a simple way to create the object. 
The example below will elaborate the factory pattern in detail.

https://www.codeproject.com/Tips/737117/Factory-Pattern-Example-in-Csharp

Using the Code
Here is the step by step procedure to create an application with Factory Pattern:

Create a new Windows project (say: ProFactoryPattern).
Add a ComboBox (name it cmbSelect) and one Label (for displaying the Result (name it lblResult)) as shown below:


Add the below interface and two classes implement this interface. Please note that both classes have the same methods.

interface IGet
{
    string ConC(string s1, string s2);
}

class clsFirst : IGet
{
    public string ConC(string s1, string s2)
    {
        string Final = "From First: " + s1+" and " + s2;
        return Final;
    }
}

class clsSecond : IGet
{
    public string ConC(string s1, string s2)
    {
        string Final = "From Second: " + s1 + " and " + s2;
        return Final;
    }
} 

Next, add the factory class, in which conditions are there to create the objects. 
Method in this class basically decides object of class to be created, as shown below:


class clsFactory
{
    static public IGet CreateandReturnObj(int cChoice)
    {
        IGet ObjSelector = null;

        switch (cChoice)
        {
            case 1:
                ObjSelector = new clsFirst();
                break;
            case 2:
                ObjSelector = new clsSecond();
                break;
            default:
                ObjSelector = new clsFirst();
                break;
        }
        return ObjSelector;

    }
}
Finally, the client code looks like shown below. In this, the client does not bother about the classes 
and class name and does not worry if any new class will be added:

private void cmbSelect_SelectedIndexChanged(object sender, EventArgs e)
{
    IGet ObjIntrface = null;
    ObjIntrface = clsFactory.CreateandReturnObj(cmbSelect.SelectedIndex + 1);
    string res = ObjIntrface.ConC("First", "Second");
    lblResult.Text = res;
}
Now the output will be:
If 1 will be selected, then object of clsFirst will be created and in case of 2, clsSecond will be created:

Points of Interest
Now consider, if we have to add one more class (say: clsThird) and we want to add one 
more case in switch condition (under class: CreateandReturnObj), then client code will 
not change. Also, you can get the input from config.








Q 36:

  public class A
    {
        public A()
        {
            Console.WriteLine("parameter less constructer called");
        }
        static A() // called once
        {
            Console.WriteLine("static constructer called");
        }
    }
    public class B : A
    {

    }
            A a1 = new A();
            A a2 = new B();
            //B a3 = new A();
            B a4 = new B();
output:
static constructer called
parameter less constructer called
parameter less constructer called
parameter less constructer called





Q 37: Named Arguments:
ans: Optional parameters and Optional arguments

using System;

class Program
{
    static void Main()
    {
        // Call the Test method several times in different ways.
        Test(name: "Perl", size: 5);
        Test(name: "Dot", size: -1);
        Test(6, "Net");
        Test(7, name: "Google");
    }

    static void Test(int size, string name)
    {
        Console.WriteLine("Size = {0}, Name = {1}", size, name);
    }
}

Output

Size = 5, Name = Perl
Size = -1, Name = Dot
Size = 6, Name = Net
Size = 7, Name = Google





Q 38: Query output:
ans:
   class C
    {
        static string name;
        static DateTime time;


        public void printDetails()
        {
            Console.WriteLine(name == null ? "No Name" : name);
            Console.WriteLine(time == null ? "No Time" : time.ToString());
        }
    }
	
	    C objC = new IQDemo.C();
        objC.printDetails();
			
output: No Name and 1/1/0001 /12.00.00 Am
			




Q 39: create java script object with properties:
ans: 
var person = {
    firstName:"John",
    lastName:"Doe",
    age:50,
    eyeColor:"blue"
};

or

var person = new Object();

person.firstName = "John";
person.lastName = "Doe";
person.age = 50;
person.eyeColor = "blue";





qns 59: data type in js:
ans: sonubfn 

string, object, number, undefined, boolean, function, null





Q 40: ArrayList and List
ans: 

1. using System.Collections;
 
2. ArrayList does not have type restriction for storing data i.e. 
it is not Type Safe. You can store anything in ArrayList. 
In fact same ArrayList can store multiple types of objects.

ArrayList arrList = new ArrayList();
arrList.Add(921);
arrList.Add("Mudassar Khan");
arrList.Add(DateTime.Now);

3. ArrayList stores all data as object thus to get it back you must remember 
what you stored where and correspondingly Type Cast it as per its original Type when stored.

int number = Convert.ToInt32(arrList[0]);
string name = arrList[1].ToString();
DateTime dt = Convert.ToDateTime(arrList[2]);

4. ArrayList is mainly for .Net 2.0 Framework projects as during that period Generic List was not invented.
5. While running a Loop on ArrayList you need to use Object data type. Thus this is another disadvantage 
as you again do not know what type of data particular item contains.

foreach (object o in arrList)
{
 
}


1. Generic List (List<T>) belongs to the System.Collections.Generic namespace, 
i.e. you need to import the following namespace.

using System.Collections.Generic;

 
2. In Generic List (List<T>), T means data type, i.e. string, int, DateTime, etc. 
Thus it will store only specific types of objects based on what data type has been 
specified while declarations i.e. it is Type Safe. Thus if you have a Generic List 
of string you can only store string values, anything else will give compilation error.
Below I had no option other than having three different Generic Lists for three different data types.

List<string> lstString = new List<string>();
lstString.Add("Mudassar Khan");
lstString.Add("Robert Hammond");
lstString.Add("Ramesh Singh");
 
List<int> lstInt = new List<int>();
lstInt.Add(991);
lstInt.Add(10);
lstInt.Add(4450);
 
List<DateTime> lstDateTime = new List<DateTime>();
lstDateTime.Add(DateTime.Now);
lstDateTime.Add(DateTime.Now.AddDays(20));
lstDateTime.Add(DateTime.Now.AddHours(-10));

 
3. Generic List stores all data of the data type it is declared thus to getting 
the data back is hassle free and no type conversions required.

int number = lstInt[0];
string name = lstString[0];
DateTime dt = lstDateTime[0];

 
4. Generic List must be used instead of ArrayList unless specific requirement for projects higher than .Net 2.0 Framework.
5. While running a Loop on Generic List again it is problem free as we exactly know what the List contains.
foreach (int number in lstInt)
{
}
foreach (string name in lstString)
{
}
foreach (DateTime dt in lstDateTime)
{
}








Q 41:Difference between Array and ArrayList in C#:
ans: 

Array	
Array is strongly typed. This means that an array can store only specific type of items\elements.
Array stores fixed number of elements. Size of an Array must be specified at the time of initialization.
No need to cast elements of an array while retriving because it is strongly type and stores specific type of items only.	
Use static helper class Array to perform different tasks on the array.

ArrayList:
ArrayList can store any type of items\elements.
ArrayList grows automatically and you don't need to specify size.
Items of ArrayList need to be cast to appropriate data type while retriving.
ArrayList itself includes various utility methods for various tasks.







Qns 42: diff between Html.BeginForm()  and Ajax.BeginForm()

a).Html.BeginForm() will create a form on the page that submits its values to the 
server as a synchronous HTTP request, refreshing the entire page in the process.
b). Will redirect the form.

a). Ajax.BeginForm() creates a form that submits its values using an asynchronous 
ajax request. This allows a portion of the page to be update without requiring 
that the entire page be refreshed.

b). Won't redirect the form even you do a RedirectAction().





Qns 43: is every request in mvc is ajax request?
ans- no
how you check using this-
Request.IsAjaxRequest()





Q 44: MVC does not use viewstate:
In Asp.Net we have Runat="Server" to make controls like Textbox,Checkbox... 
into asp.net controls which they run at server and they can maintain viewstate 
because of they are server controls.

Http is Stateless:
Http is stateless i.e; for it forgets the controls value (like Textbox,Checkbox) 
for every request that means it doesnt maintain state.To make stateful we use 
state management techniques like ViewState, Querystring, Sessions, Cookies in Asp.Net.

Coming to your Question
In MVC we dont have Viewstate





Q 45: // Creating N instance of class

 public class NumberedInstance
    {
        private static int instanceNumber;
        private NumberedInstance()
        {
 
        }
 
        public static NumberedInstance GetInstance()
        {
            if(instanceNumber < 5)
            {
                instanceNumber++;
                return new NumberedInstance();
            }
            else
            {
                throw new ArgumentOutOfRangeException("Only five instance of the class are allowed");
            }
        }
    }







Q 46: how to by pass a request in mvc if int parameter value is greater then 5,
ans: using custom attribute routing
see the below link for Route Constraints:
https://blogs.msdn.microsoft.com/webdev/2013/10/17/attribute-routing-in-asp-net-mvc-5/





Q 47: how to deal large data when consuming the web api?
Q 48: what is cursoring in web api?

Q 49: difference between string builder and string
Q 50: write function to take factorial of number
Q 51: write function to remove duplicate char from a string.
Q 52  write function to take sum of digits
Q 53  diff between int.Tryparse and int.Parse
Q 54  difference between var and dynamic and where did you use it


Q 55 : diffrence between finilizer and finnaly
Q 56 :      
       1).   try
             {

             }
         
            finally
            { } 
            will work

      2).   try
            {

            }
            catch (Exception) 
            {

                throw;
            } 
             will work
			 
		3).	try
			{
			
			} not work produce error: need catch or finally





Q 57: what is func function and result and predicate delegate in c#

             //// Generic Delegates:   Func
            // Func is built -in delegate type.
            // Func delegate type must return a value.
            // Func delegate type can have zero to 16 input parameters.
            //Func delegate type can be used with an anonymous method or lambda expression.

            //// Generic Delegates:   Action
            // Action delegate is same as func delegate except that it does not return anything.
            // Return type must be void.
            //Action delegate can have 1 to 16 input parameters.
            //Action delegate can be used with anonymous methods or lambda expressions.


            //// Generic Delegates:   Predicate
            //Predicate delegate takes one input parameter and boolean return type.
            //Predicate delegate must contains some criateria to check whether supplied parameter meets those criateria or not.
            //Anonymous method and Lambda expression can be assigned to the predicate delegate.





Q 58: diff between var, let and const keyword in javascript

var keyboard:

1). var keyword was introduced with JavaScript.
2). It has a function scope.
3). It is hoisted. 

example 1:
for(var i = 0; i<10; i++) {
  console.log(i)
}
console.log(i);

output:
0
1
2
3
4
5
6
7
8
9
10


example 2:
function printNumbers()
{
 for(var i = 0; i<10; i++) {
  console.log(i)
}
}

printNumbers();
console.log(i);

 0
 1
 2
 3
 4
 5
 6
 7
 8
 9
VM7182:12 Uncaught ReferenceError: i is not defined
    at <anonymous>:12:13
    at submitTryit (tryit.asp?filename=tryjs_strict_global:538)
    at HTMLButtonElement.onclick (tryit.asp?filename=tryjs_strict_global:422)
	
	
example 3:	
One last thing, have you ever seen JavaScript code that looks like this:

(function (){
  for(var i = 0; i<10; i++) {
    console.log(i)
  }
})();

This is an attempt to keep variables in scope to the functions, 
this is usually called immediately invoked function expression.


example 4:
//function scope  
function get(i){  
    //block scope  
  if(i>2){  
    var a = i;  
  }  
  console.log(i);  
}  
//calling function  
get(3);  
  
//access variable outside function scope  
//it will give me an error  
console.log(i);  


Output
3
Uncaught ReferenceError: i is not defined at window.onload


example 5:

Hoisting : 
When you declare a variable with var keyword, 
it will be automatically hoisted to the top of scope. 

//function scope  
function get(i){  
    //printing i variable  
  //value is undefined  
  console.log(a);  
    
  //declare variable after console but this variable hoisted to the top at //run time  
  var a = i;  
    
  //again printing i variable  
  //value is 3  
  console.log(a);  
}  
//calling function  
get(3);
  
Output:
undefined
3
 
This happens behind the scene -
//function scope    
function get(i){    
        //a hoisted to the top  
    var a;    
    //if we don't give any value to variable, by default, value is undefined.  
    //value is "undefined"  
  console.log(a);    
      
    //assigning value to a  
  a = i;    
       
  //value is 3    
  console.log(a);    
}    
//calling function    
get(3);

   
example 6:
'var' re-declaration
Re-declaring variable with var keyword refers to the same variable 
irrespective of how many times we have declared that variable.

var name = 'sheo';
var name = 'sheo';
function getName()
{
   var name = 'abc';
   console.log(name)
}
getName();
console.log(name)


output:
sheo,
abc




2.  let Keyword:
1). let keyword was introduced in ES 6 (ES 2015).
2). It has block scope.
3). It is not hoisted.


example 1:
for(let i = 0; i<10; i++) {
  console.log(i)
}
console.log(i)
It will print 0–9 then throw a reference error as i is not in scope outside the braces

example 2:

//declare a variable with var keyword 
var i = 4  
    //block scope -start  
  if(i>3)  
  {  
      //declare a variable with let keyword  
      let j= 5;  
  
      //declare a variable with var keyword  
      var k = 8;  
      //it will give me 5  
      console.log("inside block scope (let)::"+ j);  
  }  
  //block scope -end  
  
//it will give me 8.  
//var variable are available outside block scope  
console.log("ouside block scope (var)::"+ k);  
  
//it will give me an error.  
//let variable are not available outside block scope  
console.log("ouside block scope (let)::"+ j);  


Output:
inside block scope (let)::5
ouside block scope (var)::8
Uncaught ReferenceError: j is not defined at window.onload
 
Hoisting, let keyword is not hoisted.

example 3:

//program doesn't know about i variable so it will give me an error.  
console.log(i);  
//declare and initilize let variable  
let i = 25;  

Output:
Uncaught ReferenceError: i is not defined at window.onload

example 4:

'let' re-declaration
Re-declaring variable with let keyword stops us from doing so as it throws error

let name = 'sheo';
let name = 'narayan'; // error - Let/Const redeclaration


3. const keyword:

a).
const myAge = 9;
const person = {
    name: "Sheo",
    age: myAge
}
alert(person.name + ' ' + person.age); this will work? yes


b).
// Error
myAge = 10; // error, will not work

person = { // error, will not work
    name: "Sheo Narayan",
    age: myAge
};



c).
const person = { // error
    name: "Sheo Narayan",
    age: 20
};

// however the const object property value can be changed
person.name = "Narayan";
person.age = 60;

alert(person.name + ' ' + person.age);

this will work? yes


Conclusion
Always use let as much as possible to avoid the scope monster





Q 59: <h2>JavaScript Objects</h2>

<p id="objdemo"></p>
<p id="listdemo"></p>

<script>
// Create an object:
var car1 = {type:"Fiat", model:"500", color:"white"};
var car2 = {type:"Wagonr", model:"2013", color:"white"};
var car3 = {type:"Shift", model:"2018", color:"grey"};

// Display some data from the object:
document.getElementById("objdemo").innerHTML = car2.model;

var cars = new Array(car1, car2, car3);


// Display some data from the object:
document.getElementById("listdemo").innerHTML = cars[2].color;
</script>


Q 60: why we use === in js
Q 61: data type in js: 
ans : SONUBFN

S is string,
O is object
N is number
U is Undefined,
B is boolean,
F is function,
N is null


Primary Data Types:
String
Number
Boolean

Composite Data Types:
Object
Array

Special Data Types:
Null
Undefined

Example:

<h2>JavaScript typeof</h2>
<p>The typeof operator returns the type of a variable or an expression.</p>

<p id="demo"></p>

<script>
document.getElementById("demo").innerHTML = 
typeof "john" + "<br>" + 
typeof 3.14 + "<br>" +
typeof true + "<br>" +
typeof false + "<br>" +
typeof x + "<br>" +
typeof function(){} +  "<br>" +
typeof (new Array()) +  "<br>" +
typeof null 
;
</script>

output:
The typeof operator returns the type of a variable or an expression.

string
number
boolean
boolean
undefined
function
object
object











Q 62: DllImport attribute in c#

Definition - What does DllImport Attribute mean?
DllImport Attribute is a declarative tag used in C# to mark a class method as being defined in an external dynamic-link library (DLL) rather than in any .NET assembly. 

DllImport attribute is used at run time to call a function exported in an external DLL 
implemented with unmanaged code that is executed outside the control of common 
language runtime (CLR)

example:
using System;
using System.Runtime.InteropServices;

class Example
{
    // Use DllImport to import the Win32 MessageBox function.
    [DllImport("user32.dll", CharSet = CharSet.Unicode)]
    public static extern int MessageBox(IntPtr hWnd, String text, String caption, uint type);

    static void Main()
    {
        // Call the MessageBox function using platform invoke.
        MessageBox(new IntPtr(0), "Hello World!", "Hello Dialog", 0);
    }
}

Q 63: how can we create a method without defination



Q 64:  int in c#
int denotes an integral type that stores values according to the size and range shown in the following table.

Type	 Range	                           Size	             .NET Framework type	Default Value
int	-2,147,483,648 to 2,147,483,647	Signed 32-bit integer	System.Int32	         0
Literals
You can declare and initialize an int variable by assigning a decimal literal, 
a hexadecimal literal, or (starting with C# 7.0) a binary literal to it. 
If the integer literal is outside the range of int 
(that is, if it is less than Int32.MinValue or greater than Int32.MaxValue), 
a compilation error occurs.

In the following example, integers equal to 90,946 that are represented as decimal, 
hexadecimal, and binary literals are assigned to int values.

C#

Copy
int intValue1 = 90946;
Console.WriteLine(intValue1);
int intValue2 = 0x16342;
Console.WriteLine(intValue2);

int intValue3 = 0b0001_0110_0011_0100_0010;
Console.WriteLine(intValue3);
// The example displays the following output:
//          90946
//          90946
//          90946
Note

You use 
the prefix 0x or 0X to denote a hexadecimal literal and 
the prefix 0b or 0B to denote a binary literal. 
Decimal literals have no prefix.

Starting with C# 7.0, a couple of features have been added to enhance readability.

C# 7.0 allows the usage of the underscore character, _, as a digit separator.
C# 7.2 allows _ to be used as a digit separator for a binary or hexadecimal literal, after the prefix. A decimal literal isn't permitted to have a leading underscore.
Some examples are shown below.

C#

Copy
int intValue1 = 90_946;
Console.WriteLine(intValue1);

int intValue2 = 0x0001_6342;
Console.WriteLine(intValue2);

int intValue3 = 0b0001_0110_0011_0100_0010;
Console.WriteLine(intValue3);

int intValue4 = 0x_0001_6342;       // C# 7.2 onwards
Console.WriteLine(intValue4);

int intValue5 = 0b_0001_0110_0011_0100_0010;       // C# 7.2 onwards
Console.WriteLine(intValue5);
// The example displays the following output:
//          90946
//          90946
//          90946
//          90946
//          90946

reference url
https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/int





Qns 65: what is Open-Closed principle:
ans:where all our classes are Open for extension but closed for modification. 


Qns 66: https://stackoverflow.com/questions/3984163/access-private-methods-using-objects



Qns 67: managed and unmanaged resources?
Managed resources basically means "managed memory" that is managed by the garbage collector. When you no longer have any references to a managed object (which uses managed memory), the garbage collector will (eventually) release that memory for you.

Unmanaged resources are then everything that the garbage collector does not know about. For example:

Open files
Open network connections
Unmanaged memory
In XNA: vertex buffers, index buffers, textures, etc.

Normally you want to release those unmanaged resources before you lose all the references 
you have to the object managing them. You do this by calling Dispose on that object, 
or (in C#) using the using statement which will handle calling Dispose for you.

If you neglect to Dispose of your unmanaged resources correctly, 
the garbage collector will eventually handle it for you when the object containing that 
resource is garbage collected (this is "finalization"). But because the garbage collector 
doesn't know about the unmanaged resources, it can't tell how badly it needs to release 
them - so it's possible for your program to perform poorly or run out of resources 
entirely.

If you implement a class yourself that handles unmanaged resources, it is up to you to 
implement Dispose and Finalize correctly.




/// or

The term "unmanaged resource" is usually used to describe something not directly under 
the control of the garbage collector. For example, if you open a connection to a 
database server this will use resources on the server (for maintaining the connection) 
and possibly other non-.net resources on the client machine, if the provider 
isn't written entirely in managed code.

This is why, for something like a database connection, it's recommended you write your 
code thusly:

using (var connection = new SqlConnection("connection_string_here"))
{
    // Code to use connection here
}
As this ensures that .Dispose() is called on the connection object, ensuring that any 
unmanaged resources are cleaned up.

//// or

Managed resources basically mean anything managed by the CLR 
(example: any of your managed objects). Unmanaged resources typically mean native 
resources that are created and lifetime managed outside the CLR 
(example GDI handles or say sockets).


//// or

Managed resources are those that are pure .NET code and managed by the runtime and are 
under its direct control.

Unmanaged resources are those that are not. File handles, pinned memory, COM objects, 
database connections etc.




Qns 68:
$(document).ready(function(){
    $("div[class *= myclass]").css({"color": "red", "border": "2px solid red"});
});

all div elements contains class myclass




Qns 69:
The siblings() method returns all sibling elements of the selected element.
The following example returns all sibling elements of <h2>:

Example
$(document).ready(function(){
    $("h2").siblings();
});






Qns 70: on method in jquery
ans: Attach a click event to the <p> element:
$("p").on("click", function(){
    alert("The paragraph was clicked.");
});







Qns 71: default type attribute value for a button ?
Ans ie = type="button"
    other browsers= type="submit"

Value	Description
submit	The button is a submit button (this is default for all browsers, except Internet Explorer)
button	The button is a clickable button (this is default for Internet Explorer)
reset	The button is a reset button (clears form data)




Qns 72: what is solid principle:
ans:
SOLID is basically 5 principles, which will help to create a good software architecture. 
You can see that all design patterns are based on these principles. 
SOLID is basically an acronym of the following:

S is single responsibility principle (SRP)
O stands for open closed principle (OCP)
L Liskov substitution principle (LSP)
I interface segregation principle (ISP)
D Dependency injection principle (DIP)

helping url
http://blog.thedigitalgroup.com/solid-architecture-principle-using-c-with-simple-c-example


What is SOLID
SOLID principles are the design principles that enable us to manage with most of the software design problems. 
These principles provide us ways to move from tightly coupled code and little encapsulation to the desired results of loosely coupled 
and encapsulated real needs of a business properly.
 
Below are the acronym of a SOLID

    S: Single Responsibility Principle (SRP).
    O: Open closed Principle (OSP).
    L: Liskov substitution Principle (LSP).
    I: Interface Segregation Principle (ISP).
    D: Dependency Inversion Principle (DIP).


Let’s go walk through each of them below.
 
S: Single Responsibility Principle (SRP) “There should never be more than one reason for a class to change”
Simple Translation: A class should concentrate on doing one thing The SRP says a class should focus on doing one thing, 
or have one responsibility. This doesn’t mean it should only have one method, but instead all the methods should relate to a 
single purpose (i.e. should be cohesive).


For example: an Invoice class might have the responsibility of calculating various amounts based on its data. In that case it probably shouldn’t know about how to retrieve this data from a database, or how to format an invoice for print or display or logging, sending Email etc.


A class that adheres to the SRP should be easier to change than those with multiple responsibilities. If we have calculation logic and database logic and display logic all mixed up within one class it can be difficult to change one part without breaking others.
Mixing responsibilities also makes the class harder to understand, harder to test, and increases the risk of duplicating logic in other parts of the design


Violations of the SRP


public class Invoice
{
    public long Amount { get; set; }
    public DateTime InvoiceDate { get; set; }
    public void Add()
    {
        try
        {
            // Code for adding invoice
           // Once Invoice has been added , send mail 
            MailMessage mailMessage = new MailMessage("MailAddressFrom","MailAddressTo","MailSubject","MailBody");
            this.SendEmail(mailMessage);
        }
        catch (Exception ex)
        {
             System.IO.File.WriteAllText(@"c:\Error.txt", ex.ToString());
        }
    }
    public void Delete()
    {
        try
        {
            // Code for Delete invoice
        }
        catch (Exception ex)
        {
            System.IO.File.WriteAllText(@"c:\Error.txt", ex.ToString());
        }
    }
    public void SendEmail(MailMessage mailMessage)
    {
        try
        {
            // Code for getting Email setting and send invoice mail
        }
        catch (Exception ex)
        {
            System.IO.File.WriteAllText(@"c:\Error.txt", ex.ToString());
        }
    }
}


This Invoice class violating SRP, as It has his own responsibility i.e. Add, Delete invoice and also has extra activity like logging and Sending email as well.


A solution lets refactor it


public class Invoice
{
    public long Amount { get; set; }
    public DateTime InvoiceDate { get; set; }
    private FileLogger fileLogger;
    private MailSender mailSender;
    public Invoice()
    {
        fileLogger = new FileLogger();
        mailSender = new MailSender();
    }
    public void Add()
    {
        try
        {
            fileLogger.Info("Add method Start");
            // Code for adding invoice
            // Once Invoice has been added , send mail 
            mailSender.From = "rakesh.girase@thedigitalgroup.net";
            mailSender.To = "customers@digitalgroup.com";
            mailSender.Subject = "TestMail";
            mailSender.Body = "This is a text mail";
            mailSender.SendEmail();
        }
        catch (Exception ex)
        {
            fileLogger.Error("Error while Adding Invoice", ex);
        }
    }
    public void Delete()
    {
        try
        {
            fileLogger.Info("Add Delete Start");
            // Code for Delete invoice
        }
        catch (Exception ex)
        {
            fileLogger.Error("Error while Deleting Invoice", ex);
        }
    }
}
public interface ILogger
{
    void Info(string info);
    void Debug(string info);
    void Error(string message, Exception ex);
}
    
public class FileLogger : ILogger
{
    public FileLogger()
    {
        // Code for initialization i.e. Creating Log file with specified  
        // details
    }
    public void Info(string info)
    {
        // Code for writing details into text file 
    }
    public void Debug(string info)
    {
        // Code for writing debug information into text file 
    }
    public void Error(string message, Exception ex)
    {
        // Code for writing Error with message and exception detail
    }
}
public class MailSender
{
    public string From { get; set; }
    public string To { get; set; }
    public string Subject { get; set; }
    public string Body { get; set; }
    public void SendEmail()
    {
        // Code for sending mail
    }
}


Now Invoice class can happily delegate the logging activity to the “FileLogger” class and Sending mail activity to “MailSender” class. This way Invoice class can concentrate on Invoice related activities.
 
O: Open closed Principle (OSP) 
“Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.”
Simple Translation: Change a class’ behavior using inheritance and composition. Here “Open for extension” means, 
we need to design our module/class in such a way that the new functionality can be added only when new requirements are generated.
 “Closed for modification” means we have already developed a class and it has gone through unit testing.
 We should then not alter it until we find bugs. As it says, a class should be open for extensions,
 we can use inheritance to do this.
Let’s continue with our same Invoice class example. I have added a simple Invoice type property to the class. 
This property decided if this is a “Final” Or “Proposed” invoice.


Depending on the same it calculates discount. Have a look at the “GetDiscount” function which returns discount accordingly.


Violation of OSP


public enum InvoiceType
{
    Final,Proposed
};
public class Invoice
{
    public InvoiceType InvoiceType { get; set; }
    public double GetDiscount(double amount,InvoiceType invoiceType)
    {
        double finalAmount = 0;
        if (invoiceType == InvoiceType.Final)
        {
            finalAmount = amount - 100;
        }
        else if(invoiceType == InvoiceType.Proposed)
        {
            finalAmount = amount - 50;
        }
        return finalAmount;
    }
}
The problem is if we add a new invoice type, we need to go and add one more “IF” condition in the “GetDiscount” function, in other words we need to change the invoice class.
If we are changing the Invoice class again and again, we need to ensure that the previous conditions with new one’s are tested again , existing client’s which are referencing this class are working properly as before.
In other words we are “MODIFYING” the current invoice code for every change and every time we modify we need to ensure that all the previous functionality and connected client are working as before.
How about rather than “MODIFYING” , we go for “EXTENSION”. In other words every time a new invoice type needs to be added we create a new class as shown in the below. So whatever is the current code they are untouched and we just need to test and check the new classes.
Solution, let’s refactor it
namespace SOLID_Principles_OSP_S
{
    public enum InvoiceType
    {
        Final, Proposed
    };
    
    public class Invoice
    {
        public InvoiceType InvoiceType { get; set; }
        public virtual double GetDiscount(double amount)
        {
            double finalAmount = 300;
            return finalAmount;
        }
    }
    public class FinalInvoice : Invoice
    {
        public override double GetDiscount(double amount)
        {
            return base.GetDiscount(amount) - 100;
        }
    }
    
    public class ProposedInvoice : Invoice
    {
        public override double GetDiscount(double amount)
        {
            return base.GetDiscount(amount) - 50;
        }
    }
    
    public class RecurringInvoice : Invoice
    {
        public override double GetDiscount(double amount)
        {
            return base.GetDiscount(amount) - 200;
        }
    }
}


Putting in simple words the “Invoice” class is now closed for any new modification but it’s open for extensions when new Invoice types are added to the project.
 
L: Liskov substitution Principle (LSP) 
“Objects in a program should be replaceable with instances of their sub types without altering the correctness of that program”
Simple Translation: We must make sure that new derived classes are extending the base classes without changing their behavior
LSP states that the derived classes should be perfectly substitutable for their base classes.
 If class D is derived from A then D should be substitutable for A.


Look at the following C# code sample where the LSP is broken. Simply, an Orange cannot substitute an Apple, which results in printing the colour of apple as Orange.


Violation of LSP


namespace SOLID_Principles_LSP_V
{
  
    class Program
    {
        static void Main(string[] args)
        {
            Apple apple = new Orange();
            Console.WriteLine(apple.GetColor());
        }
    }
    public class Apple
    {
        public virtual string GetColor()
        {
            return "Red";
        }
    }
    public class Orange : Apple
    {
        public override string GetColor()
        {
            return "Orange";
        }
    }
}
 Solution, refactor
Now let us re-factor and make it comply with LSP by having a generic base class for both Apple and Orange.
namespace SOLID_Principles_LSP_S
{
    class Program
    {
        static void Main(string[] args)
        {
            Fruit fruit = new Orange();
            Console.WriteLine(fruit.GetColor());
            fruit = new Apple();
            Console.WriteLine(fruit.GetColor());
        }
    }
    public abstract class Fruit
    {
        public abstract string GetColor();
    }
    public class Apple : Fruit
    {
        public override string GetColor()
        {
            return "Red";
        }
    }
    public class Orange : Apple
    {
        public override string GetColor()
        {
            return "Orange";
        }
    }
}
 
I: Interface Segregation Principle (ISP) 
“Clients should not be forced to implement interfaces they don’t use. Instead of one fat interface, many small interfaces are preferred based on groups of methods, each one serving one sub module.“
Simple Translation: ”No client consuming an interface should be forced to depend on methods it does not use”
Let’s start with an example that breaks ISP. Suppose we need to build a system for an IT firm that contains roles like TeamLead and Programmer where TeamLead divides a huge task into smaller tasks and assigns them to his/her programmers or can directly work on them.


Based on specifications, we need to create an interface and a TeamLead class to implement it.


namespace SOLID_Principles_ISP_V
{
   
    public interface ILead
    {
        void CreateSubTask();
        void AssginTask();
        void WorkOnTask();
    }
    
    public class TeamLead : ILead
    {
        public void AssignTask()
        {
            //Code to assign a task.  
        }
        public void CreateSubTask()
        {
            //Code to create a sub task  
        }
        public void WorkOnTask()
        {
            //Code to implement perform assigned task.  
        }
    }
}
The design looks fine for now. Later another role like Manager, who assigns tasks to TeamLead and will not work on the tasks, is introduced into the system. Can we directly implement an ILead interface in the Manager class, like the following?
public class Manager : ILead
    {
        public void AssignTask()
        {
            //Code to assign a task.  
        }
        public void CreateSubTask()
        {
            //Code to create a sub task.  
        }
        public void WorkOnTask()
        {
            throw new Exception("Manager can't work on Task");
        }
    }   


Since the Manager can’t work on a task and at the same time no one can assign tasks to the Manager, this WorkOnTask() should not be in the Manager class. But we are implementing this class from the ILead interface, we need to provide a concrete Method. Here we are forcing the Manager class to implement a WorkOnTask() method without a purpose. This is wrong. The design violates ISP. Let’s correct the design.


Since we have three roles,1. Manager, that can only divide and assign the tasks, 2. TeamLead that can divide and assign the tasks and can work on them as well, 3. Programmer that can only work on tasks, we need to divide the responsibilities by segregating the ILead interface. An interface that provides a contract for WorkOnTask().


A solution, lets refactor it


namespace SOLID_Principles_ISP_S
{
    public interface IProgrammer
    {
        void WorkOnTask();
    }
    public interface ILead
    {
        void AssignTask();
        void CreateSubTask();
    }
    public class Programmer : IProgrammer
    {
        public void WorkOnTask()
        {
            //code to implement to work on the Task.  
        }
    }
    
    public class Manager : ILead
    {
        public void AssignTask()
        {
            //Code to assign a Task  
        }
        public void CreateSubTask()
        {
            //Code to create a sub taks from a task.  
        }
    }
    
    public class TeamLead : IProgrammer, ILead
    {
        public void AssignTask()
        {
            //Code to assign a Task  
        }
        public void CreateSubTask()
        {
            //Code to create a sub task from a task.  
        }
        public void WorkOnTask()
        {
            //code to implement to work on the Task.  
        }
    }
}


Here we separated responsibilities/purposes and distributed them on multiple Interfaces and provided a good level of abstraction too.
 
D: Dependency Inversion Principle (DIP)

 “High-level modules should not depend on low-level modules. 
Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.”

Simple Translation: High level module and Low level module keep as loosely couple as much as we can.
When a class knows explicitly about the design and implementation of another class, it raises the risk that changes to one class will break the other class. So we must keep these high-level and low-level modules/class loosely coupled as much as we can. To do that, we need to make both of them dependent on abstractions instead of knowing each other. Let’s start with an example.

Suppose we need to work on an error logging module that logs exception stack traces into a file. Simple, isn’t it? The following are the classes that provide functionality to log a stack trace into a file.


public class FileLogger
{
    public void LogMessage(string aStackTrace)
    {
        //code to log stack trace into a file.  
    }
}
public static class ExceptionLogger
{
    public static void LogIntoFile(Exception aException)
    {
        FileLogger objFileLogger = new FileLogger();
        objFileLogger.LogMessage(GetUserReadableMessage(aException));
    }
    private static string GetUserReadableMessage(Exception ex)
    {
        string strMessage = string.Empty;
        //code to convert Exception's stack trace and message to user readable format.  
        return strMessage;
    }
}
public class DataExporter
{
    public void ExportDataFromFile()
    {
        try
        {
            //code to export data from files to database.  
        }
        catch (Exception ex)
        {
            new ExceptionLogger.LogIntoFile(ex);
        }
    }
}
Looks good. We sent our application to the client. But our client wants to store this stack trace in a database if an IO exception occurs. Hmm… okay, no problem. We can implement that too. Here we need to add one more class that provides the functionality to log the stack trace into the database and an extra method in ExceptionLogger to interact with our new class to log the stack trace.
namespace SOLID_Principles
{
    public class DbLogger
    {
        public void LogMessage(string aMessage)
        {
            //Code to write message in database.  
        }
    }
    
    public class FileLogger
    {
        public void LogMessage(string aStackTrace)
        {
            //code to log stack trace into a file.  
        }
    }
    
    public class ExceptionLogger
    {
        public void LogIntoFile(Exception aException)
        {
            FileLogger objFileLogger = new FileLogger();
            objFileLogger.LogMessage(GetUserReadableMessage(aException));
        }
        public void LogIntoDataBase(Exception aException)
        {
            DbLogger objDbLogger = new DbLogger();
            objDbLogger.LogMessage(GetUserReadableMessage(aException));
        }
        private string GetUserReadableMessage(Exception ex)
        {
            string strMessage = string.Empty;
            //code to convert Exception's stack trace and message to user   
             readable format.  
            return strMessage;
        }
    }
    
    public class DataExporter
    {
        public void ExportDataFromFile()
        {
            try
            {
                //code to export data from files to database.  
            }
            catch (IOException ex)
            {
                new ExceptionLogger().LogIntoDataBase(ex);
            }
            catch (Exception ex)
            {
                new ExceptionLogger().LogIntoFile(ex);
            }
        }
    }
}


Looks fine for now. But whenever the client wants to introduce a new logger, we need to alter ExceptionLogger by adding a new method. If we continue doing this after some time then we will see a fat ExceptionLogger class with a large set of methods that provide the functionality to log a message into various targets. Why does this issue occur? Because ExceptionLogger directly contacts the low-level classes FileLogger and and DbLogger to log the exception. We need to alter the design so that this ExceptionLogger class can be loosely coupled with those class. To do that we need to introduce an abstraction between them, so that ExcetpionLogger can contact the abstraction to log the exception instead of depending on the low-level classes directly.


Solution: Lets refactor it


Now, we move to the low-level class’s initiation from the ExcetpionLogger class to the DataExporter class to make ExceptionLogger loosely coupled with the low-level classes FileLogger and EventLogger. And by doing that we are giving provision to DataExporter class to decide what kind of Logger should be called based on the exception that occurs.


namespace SOLID_Principles_DIP_S
{
    
    public interface ILogger
    {
        void LogMessage(string aString);
    }
    public class DbLogger : ILogger
    {
        public void LogMessage(string aMessage)
        {
            //Code to write message in database.  
        }
    }
    
    public class FileLogger : ILogger
    {
        public void LogMessage(string aStackTrace)
        {
            //code to log stack trace into a file.  
        }
    }
    
    public class ExceptionLogger
    {
        private ILogger _logger;
        public ExceptionLogger(ILogger aLogger)
        {
            this._logger = aLogger;
        }
        public void LogException(Exception aException)
        {
            string strMessage = GetUserReadableMessage(aException);
            this._logger.LogMessage(strMessage);
        }
        private string GetUserReadableMessage(Exception aException)
        {
            string strMessage = string.Empty;
            //code to convert Exception's stack trace and message to user readable format.  
            return strMessage;
        }
    }
    
    public class DataExporter
    {
        public void ExportDataFromFile()
        {
            ExceptionLogger _exceptionLogger;
            try
            {
                //code to export data from files to database.  
            }
            catch (IOException ex)
            {
                _exceptionLogger = new ExceptionLogger(new DbLogger());
                _exceptionLogger.LogException(ex);
            }
            catch (Exception ex)
            {
                _exceptionLogger = new ExceptionLogger(new FileLogger());
                _exceptionLogger.LogException(ex);
            }
        }
    }
}


Now the high level (FileLogger and DBLogger) and low level (DataExporter) models are loosely couple.
 
Conclusion: We have gone through all the five SOLID principles successfully with a simple C# example.
SOLID principles of object-oriented programming allow us to write structured and neat code that is easy to extend and maintain
Please post your reply, Happy coding.





Qns 73: what is CTS (Common Type System)
ans:Common Type System(CTS)
CTS defines how types are declared, used, and managed in the common language runtime(CLR) 





Qns 74: What is "managed code"?
ans:
"managed code": code whose execution is managed by Common Language Runtime or CLR
regardless of the implementation (Mono or .NET Framework or .NET Core). 
CLR is in charge of taking the managed code, compiling it into machine code and then executing it. 
On top of that, runtime provides several important services such as:
 automatic memory management, 
 security boundaries, 
 type safety etc.





Qns 75: What is "Unmanaged code"?
ans:
Unmanaged code: Which does not have the CLR support(old c++ code), 
or
Code that is directly executed by the Operating System is known as un-managed code.
therefore unmanaged code does not have a garbage collector and 
you will have to keep track of all your memory allocations to avoid memory leaks. 
Also when you build an unmanaged project in Visual Studio, 
the resulting library or executable is written directly on machine code, 


The managed C++ has CLR support and its code is written in an extension of the C++ language called C++/CLI, 
this extension allows you to use the Garbage Collector and the .NET Framework classes.

Unmanaged Code:
Code that is directly executed by the Operating System is known as un-managed code.
Typically applications written in VB 6.0, C++, C, etc are all examples of unmanaged code.

In unmanaged code the memory allocation, type safety, security, 
etc needs to be taken care of by the developer

note: 
Apps Which is directly run under the OS are known as
un-managed apps

whereas apps which run under the .net framework are known as
managed apps

Unmanaged Code
Unmanaged codes are directly converted to machine language. OS can directly execute them. 
MSIL does not understand what it is and it cannot run under CLR. This type of codes are not written in .Net language (like C#, VB.net.). 
CLR does not have any control over the source code.


Note: Cleaning Up Unmanaged Resources

For the majority of the objects that your app creates, 
you can rely on .NET's garbage collector to handle memory management. 
However, when you create objects that include unmanaged resources, 
you must explicitly release those resources when you finish using them in your app. 
The most common types of unmanaged resource are objects that wrap operating system resources, 
such as files, windows, network connections, or database connections. 
Although the garbage collector is able to track the lifetime of an object that encapsulates an unmanaged resource, 
it doesn't know how to release and clean up the unmanaged resource.

If your types use unmanaged resources, you should do the following:
Implement the dispose pattern. 
This requires that you provide an IDisposable.Dispose implementation to enable the deterministic release of unmanaged resources. 
A consumer of your type calls Dispose when the object (and the resources it uses) is no longer needed. 
The Dispose method immediately releases the unmanaged resources.

Reference
System.IDisposable
Defines the Dispose method for releasing unmanaged resources.

Object.Finalize
Provides for object finalization if unmanaged resources are not released by the Dispose method.

GC.SuppressFinalize
Suppresses finalization. This method is customarily called from a Dispose method to prevent a finalizer from executing.

https://msdn.microsoft.com/en-us/library/b1yfkh5e(v=vs.100).aspx



using System;
using System.ComponentModel;

// The following example demonstrates how to create
// a resource class that implements the IDisposable interface
// and the IDisposable.Dispose method.

public class DisposeExample
{
    // A base class that implements IDisposable.
    // By implementing IDisposable, you are announcing that
    // instances of this type allocate scarce resources.
    public class MyResource: IDisposable
    {
        // Pointer to an external unmanaged resource.
        private IntPtr handle;
        // Other managed resource this class uses.
        private Component component = new Component();
        // Track whether Dispose has been called.
        private bool disposed = false;

        // The class constructor.
        public MyResource(IntPtr handle)
        {
            this.handle = handle;
        }

        // Implement IDisposable.
        // Do not make this method virtual.
        // A derived class should not be able to override this method.
        public void Dispose()
        {
            Dispose(true);
            // This object will be cleaned up by the Dispose method.
            // Therefore, you should call GC.SupressFinalize to
            // take this object off the finalization queue
            // and prevent finalization code for this object
            // from executing a second time.
            GC.SuppressFinalize(this);
        }

        // Dispose(bool disposing) executes in two distinct scenarios.
        // If disposing equals true, the method has been called directly
        // or indirectly by a user's code. Managed and unmanaged resources
        // can be disposed.
        // If disposing equals false, the method has been called by the
        // runtime from inside the finalizer and you should not reference
        // other objects. Only unmanaged resources can be disposed.
        protected virtual void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if(!this.disposed)
            {
                // If disposing equals true, dispose all managed
                // and unmanaged resources.
                if(disposing)
                {
                    // Dispose managed resources.
                    component.Dispose();
                }

                // Call the appropriate methods to clean up
                // unmanaged resources here.
                // If disposing is false,
                // only the following code is executed.
                CloseHandle(handle);
                handle = IntPtr.Zero;

                // Note disposing has been done.
                disposed = true;

            }
        }

        // Use interop to call the method necessary
        // to clean up the unmanaged resource.
        [System.Runtime.InteropServices.DllImport("Kernel32")]
        private extern static Boolean CloseHandle(IntPtr handle);

        // Use C# destructor syntax for finalization code.
        // This destructor will run only if the Dispose method
        // does not get called.
        // It gives your base class the opportunity to finalize.
        // Do not provide destructors in types derived from this class.
        ~MyResource()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }
    }
    public static void Main()
    {
        // Insert code here to create
        // and use the MyResource object.
    }
}


Garbage Collection

The .NET Framework's garbage collector manages the allocation and release of memory for your application. 
Each time you create a new object, the common language runtime allocates memory for the object from the managed heap. 
As long as address space is available in the managed heap, the runtime continues to allocate space for new objects. 
However, memory is not infinite. Eventually the garbage collector must perform a collection in order to free some memory. 
The garbage collector's optimizing engine determines the best time to perform a collection, 
based upon the allocations being made. 
When the garbage collector performs a collection, it checks for objects in the managed heap 
that are no longer being used by the application and performs the necessary operations to reclaim their memory.






Qns 76: Difference between Managed Code and Unmanaged Code?

In managed code memory allocation and release is managed by underlying system (like JVM in java and CLR in .NET) 
whereas in Unmanaged code programmer need to do that (like destroying pointers in C).

Managed Code
Managed codes are not directly converted to machine language. 
After compiled all the codes are converted to an intermediate language MSIL (Microsoft Intermediate Language). 
CLR of .Net Framework then convert it into machine language. In short all the intermediate languages (IL) are managed code. 
This type of codes are written in .net language like (C#, VB.net.). CLR has full control over the source code.

Example: C#, VB codes.

Unmanaged Code
Unmanaged codes are directly converted to machine language. OS can directly execute them. 
MSIL does not understand what it is and it cannot run under CLR. This type of codes are not written in .Net language (like C#, VB.net.). 
CLR does not have any control over the source code.

Example: java, C codes.


Managed Code:            
1.   Managed code is executed under the control of CLR (Common Language Runtime).
2.   There is no explicit memory allocation and de-allocation.
3.   There is no explicit call to the garbage collector.
     Managed code= .NET Programs

Unmanaged Code:
Code that is directly executed by the operating system is known as unmanaged code or unsafe code.
Unsafe code is code which does not execute under full control CLR. It can cause some problems, therefore, each use must be marked as unsafe.
Fixed: In an unsafe context, the fixed keyword can be used to temporarily fix a variable so that its address may be found.
Right click on your project >>properties>> go to the build tab>> check unsafe code checkbox


Managed Code:     
The code, which is developed in .NET framework, is known as managed code. 
This code is directly executed by CLR with help of managed code execution. 
Any language that is written in .NET Framework is managed code

Unmanaged Code:
The code, which is developed outside .NET, Framework is known as unmanaged code.

Most of time you use Unmanaged Code already exist because you do not want to waste your money and time
Another reason you may write Unmanaged code if you need a feature that is not avilabe through .Net Framework
and it is  avilable in windows API  for example

One advantage of unmanaged code is that since it is compiled to machine language, it is difficult to reverse-engineer.









Qns 77: what is GAC?
ans: 
GAC "Global Assembly Cache". 
It is a common place in the OS where assemblies that are going to be shared 
between different applications can be stored.

GAC path

1) C:\Windows\Assembly (for .NET 2.0 ~ 3.5)
2) C:\WINDOWS\Micorosoft.NET\assembly (for .NET 4.0)

How to install an assembly into GAC (as Administrator)
1) Drag and Drop
2) Use GacUtil.exe with Visual Studio Command Prompt
 gacutil -i [Path][Assembly Name].dll

Note: To install an assembly into the GAC, the assembly must be strongly named. 
Otherwise you get an error like this: Failure adding assembly to the cache: 
Attempt to install an assembly without a strong name.

How to uninstall an assembly from GAC (as Administrator)
gacutil -u [Assembly Name], Version=1.0.0.0, PublickeyToken=7896a3567gh












Qns 78: Difference between Encapsulation and Abstraction?
ans:
Encapsulate hides variables or some implementation that may be changed so often in a 
class to prevent outsiders access it directly. They must access it via getter and setter methods.

Ex:
class Test
{
 private string _firstName;
 
 public string FirstName
 {
  get
  {
    return _firstName;
  }
  set  
  {
   _firstName = value;
  }
 }
}

Abstraction is used to hiding something too 
but in a higher degree(class, interface). 
Clients use an abstract class(or interface) do not care about who or which it was, 
they just need to know what it can do.
or
Encapsulation: It is the process of hiding the implementation complexity of a specific class from the client 
that is going to use it, keep in mind that the "client" may be a program or event the person who wrote the class.


Note: field always should be protected or private under the class according to opps
to hide internal class structure.








Qns 79: What is the difference between loose coupling and tight coupling in the object oriented paradigm?
Ans:
Tight coupling is when a group of classes are highly dependent on one another.
This scenario arises when a class assumes too many responsibilities, or when 
one concern is spread over many classes rather than having its own class.

Loose coupling is achieved by means of a design that promotes single-responsibility and separation of concerns.
A loosely-coupled class can be consumed and tested independently of other (concrete) classes.

///Interfaces are a powerful tool to use for decoupling.///
///Interfaces are a powerful tool to use for decoupling.///
///Interfaces are a powerful tool to use for decoupling.///

Classes can communicate through interfaces rather than other concrete classes, 
and any class can be on the other end of that communication simply by implementing the interface.

Example of tight coupling:

class CustomerRepository
{
    private readonly Database database;

    public CustomerRepository(Database database)
    {
        this.database = database;
    }

    public void Add(string CustomerName)
    {
        database.AddRow("Customer", CustomerName);
    }
}

class Database
{
    public void AddRow(string Table, string Value)
    {
    }
}

Example of loose coupling:

class CustomerRepository
{
    private readonly IDatabase database;

    public CustomerRepository(IDatabase database)
    {
        this.database = database;
    }

    public void Add(string CustomerName)
    {
        database.AddRow("Customer", CustomerName);
    }
}

interface IDatabase
{
    void AddRow(string Table, string Value);
}

class Database : IDatabase
{
    public void AddRow(string Table, string Value)
    {
    }
}






Qns 80: what is upcasting and downcasting?
ans: 
Upcasting converts an object of a specialized type to a more general type. 
Downcasting converts an object from a general type to a more specialized type. 


Upcasting is an operation that creates a base class reference from a subclass reference. 
(subclass -> superclass) (i.e. Manager -> Employee)

Downcasting is an operation that creates a subclass reference from a base class reference. 
(superclass -> subclass) (i.e. Employee -> Manager)

In your case
   Manager mgr = new Manager();
   Employee emp = (Employee)mgr;

Employee emp = (Employee)mgr; //mgr is Manager
you are doing an upcasting.







Qns 81: differenec between dict and hash table?
ans:
  
1).
hash table comes under namespace System.Collections 
dict comes under namespace System.Collections.Generic 

2).
Trying to acess a inexistent key gives runtime error in Dictionary
 but no problem in hashtable as it returns null instead of error.

Note:
Hashtable is basically a List with no possibility of duplicates (and better performance in some scenarios)



Qns 82: what is boxing and unboxing?
ans:
Converting a Value Type to a Reference Type is called Boxing => VRB
and the reverse operation is called Unboxing.





Qns 83: order of execution for mvc filter 
ans 
Authentication filters(comes with mvc 5, attribute routing is also added in mvc 5) ==> interface IAuthenticationFilter {  void OnAuthentication(AuthenticationContext filterContext); void OnAuthenticationChallenge(AuthenticationChallengeContext filterContext); }
Authorization filter ==> interface IAuthorizationFilter { Void OnAutorization(AuthorizationContextfilterContext); }
Action filter ==> interface IActionFilter{  void OnActionExecuting ActionExecutingContext filterContext);  void OnActionExecuted(ActionExecutedContext filterContext);  }
Result filter ==>  interface IResultFilter{  void OnResultExecuted(ResultExecutedContext filterContext);  void OnResultExecuting(ResultExecutingContext filterContext);  }
Exceptionfilter==> interface IExceptionFilter  {  void OnException(ExceptionContextfilterContext);  } 

Note: 
The base ActionFilterAttribute class has the following methods that you can override:

OnActionExecuting – This method is called before a controller action is executed.
OnActionExecuted – This method is called after a controller action is executed.
OnResultExecuting – This method is called before a controller action result is executed.
OnResultExecuted – This method is called after a controller action result is executed.








Qns 84: Restful API - how to handle large amounts of data
Ans: You can change your API to include additional parameters to limit the scope of data returned by your application.
For instance, you could add limit and offset parameters to fetch just a little part. 
This is how pagination can be done in accordance with REST. A request like this would 
result in fetching 10 resources from the messages collection, from 21st to 30th. 
This way you can ask for a specific portion of a huge data set:

example:
myapi.co.uk/messages?limit=10&offset=20 






Qns 85: jQuery - The noConflict() Method?
ans: What if you wish to use other javascript frameworks ( Angular, Backbone, Ember, Knockout, reactjs) on your pages, 
while still using jQuery?

As you already know; jQuery uses the $ sign as a shortcut for jQuery.
There are many other popular JavaScript frameworks like: Angular, Backbone, Ember, Knockout, and more.
What if other JavaScript frameworks also use the $ sign as a shortcut?
If two different frameworks are using the same shortcut, one of them might stop working.
The jQuery team have already thought about this, and implemented the noConflict() method.

The jQuery noConflict() Method
The noConflict() method releases the hold on the $ shortcut identifier, so that other scripts can use it.

You can of course still use jQuery, simply by writing the full name instead of the shortcut:

Example
$.noConflict();
jQuery(document).ready(function(){
    jQuery("button").click(function(){
        jQuery("p").text("jQuery is still working!");
    });
});

You can also create your own shortcut very easily. 
The noConflict() method returns a reference to jQuery, 
that you can save in a variable, for later use. Here is an example:

Example
var jq = $.noConflict();
jq(document).ready(function(){
    jq("button").click(function(){
        jq("p").text("jQuery is still working!");
    });
});
If you have a block of jQuery code which uses the $ shortcut and 
you do not want to change it all, you can pass the $ sign in as a 
parameter to the ready method. This allows you to access jQuery using $, 
inside this function - outside of it, you will have to use "jQuery":

Example
$.noConflict();
jQuery(document).ready(function($){
    $("button").click(function(){
        $("p").text("jQuery is still working!");
    });
});





Qns 86: Whether our own specific characters are used in place of $ in jQuery?
ans: Yes, We can use our own variable in place of $ by using the method called no Conflict () method.

var sample = $.noConflict();
sample('#elementId').val(); //works fine




Qns 87: Can we add more than one ‘document.ready’ function in a page?
ans: Yes, we can add more than one document.ready function in a page. 
     But, body.onload can be added once in a page.





Qns 88: can we use the keywords as the variable name in c#
      yes,
      ex: int @int
          byte @ byte



Qns 89: what is an endpoint ?
ans: An endpoint is a URL pattern used to communicate with an API.
     an endpoint is simply one end of a communication channel.







Qns 90: Token Based Authentication in Web API 2 via OWIN 
ans: it is 4 steps based only
helping url
https://blogs.perficient.com/2017/06/11/token-based-authentication-in-web-api-2-via-owin/

// install these dependency to empty web api application
Install-Package Microsoft.AspNet.WebApi.Owin -Version 5.2.2
Install-Package Microsoft.Owin.Host.SystemWeb -Version 2.1.0
Install-Package Microsoft.AspNet.Identity.Owin -Version 2.0.1
Install-Package Microsoft.AspNet.Identity.EntityFramework -Version 2.0.1
Install-Package Microsoft.Owin.Security.OAuth -Version 2.1.0
Install-Package Microsoft.Owin.Cors -Version 2.1.0

you need to use 
OAuthAuthorizationServerOptions, 
OAuthAuthorizationServerProviders,
WebApiConfig and 
TokenTestController 

1). make sure you do have this class
public static class WebApiConfig
    {
        public static void Register(HttpConfiguration config)
        {
            // Web API configuration and services

            // Web API routes
            config.MapHttpAttributeRoutes();

            config.Routes.MapHttpRoute(
                name: "DefaultApi",
                routeTemplate: "api/{controller}/{id}",
                defaults: new { id = RouteParameter.Optional }
            );
        }
    }

2).

 public class SimpleAuthorizationServerProvider: OAuthAuthorizationServerProvider
    {
        
        //
        // Summary:
        //     Called at the final stage of an incoming Authorize endpoint request before the
        //     execution continues on to the web application component responsible for producing
        //     the html response. Anything present in the OWIN pipeline following the Authorization
        //     Server may produce the response for the Authorize page. If running on IIS any
        //     ASP.NET technology running on the server may produce the response for the Authorize
        //     page. If the web application wishes to produce the response directly in the AuthorizeEndpoint
        //     call it may write to the context.Response directly and should call context.RequestCompleted
        //     to stop other handlers from executing. If the web application wishes to grant
        //     the authorization directly in the AuthorizeEndpoint call it cay call context.OwinContext.Authentication.SignIn
        //     with the appropriate ClaimsIdentity and should call context.RequestCompleted
        //     to stop other handlers from executing.
        //
        // Parameters:
        //   context:
        //     The context of the event carries information in and results out.
        //
        // Returns:
        //     Task to enable asynchronous execution
        public virtual Task AuthorizeEndpoint(OAuthAuthorizeEndpointContext context);
        //
        // Summary:
        //     Called when a request to the Token endpoint arrives with a "grant_type" of "authorization_code".
        //     This occurs after the Authorize endpoint as redirected the user-agent back to
        //     the client with a "code" parameter, and the client is exchanging that for an
        //     "access_token". The claims and properties associated with the authorization code
        //     are present in the context.Ticket. The application must call context.Validated
        //     to instruct the Authorization Server middleware to issue an access token based
        //     on those claims and properties. The call to context.Validated may be given a
        //     different AuthenticationTicket or ClaimsIdentity in order to control which information
        //     flows from authorization code to access token. The default behavior when using
        //     the OAuthAuthorizationServerProvider is to flow information from the authorization
        //     code to the access token unmodified. See also http://tools.ietf.org/html/rfc6749#section-4.1.3
        //
        // Parameters:
        //   context:
        //     The context of the event carries information in and results out.
        //
        // Returns:
        //     Task to enable asynchronous execution
        public virtual Task GrantAuthorizationCode(OAuthGrantAuthorizationCodeContext context);
        //
        // Summary:
        //     Called when a request to the Token endpoint arrives with a "grant_type" of "client_credentials".
        //     This occurs when a registered client application wishes to acquire an "access_token"
        //     to interact with protected resources on it's own behalf, rather than on behalf
        //     of an authenticated user. If the web application supports the client credentials
        //     it may assume the context.ClientId has been validated by the ValidateClientAuthentication
        //     call. To issue an access token the context.Validated must be called with a new
        //     ticket containing the claims about the client application which should be associated
        //     with the access token. The application should take appropriate measures to ensure
        //     that the endpoint isn’t abused by malicious callers. The default behavior is
        //     to reject this grant type. See also http://tools.ietf.org/html/rfc6749#section-4.4.2
        //
        // Parameters:
        //   context:
        //     The context of the event carries information in and results out.
        //
        // Returns:
        //     Task to enable asynchronous execution
        public virtual Task GrantClientCredentials(OAuthGrantClientCredentialsContext context);
        //
        // Summary:
        //     Called when a request to the Token andpoint arrives with a "grant_type" of any
        //     other value. If the application supports custom grant types it is entirely responsible
        //     for determining if the request should result in an access_token. If context.Validated
        //     is called with ticket information the response body is produced in the same way
        //     as the other standard grant types. If additional response parameters must be
        //     included they may be added in the final TokenEndpoint call. See also http://tools.ietf.org/html/rfc6749#section-4.5
        //
        // Parameters:
        //   context:
        //     The context of the event carries information in and results out.
        //
        // Returns:
        //     Task to enable asynchronous execution
        public virtual Task GrantCustomExtension(OAuthGrantCustomExtensionContext context);
        //
        // Summary:
        //     Called when a request to the Token endpoint arrives with a "grant_type" of "refresh_token".
        //     This occurs if your application has issued a "refresh_token" along with the "access_token",
        //     and the client is attempting to use the "refresh_token" to acquire a new "access_token",
        //     and possibly a new "refresh_token". To issue a refresh token the an Options.RefreshTokenProvider
        //     must be assigned to create the value which is returned. The claims and properties
        //     associated with the refresh token are present in the context.Ticket. The application
        //     must call context.Validated to instruct the Authorization Server middleware to
        //     issue an access token based on those claims and properties. The call to context.Validated
        //     may be given a different AuthenticationTicket or ClaimsIdentity in order to control
        //     which information flows from the refresh token to the access token. The default
        //     behavior when using the OAuthAuthorizationServerProvider is to flow information
        //     from the refresh token to the access token unmodified. See also http://tools.ietf.org/html/rfc6749#section-6
        //
        // Parameters:
        //   context:
        //     The context of the event carries information in and results out.
        //
        // Returns:
        //     Task to enable asynchronous execution
        public virtual Task GrantRefreshToken(OAuthGrantRefreshTokenContext context);
        //
        // Summary:
        //     Called when a request to the Token endpoint arrives with a "grant_type" of "password".
        //     This occurs when the user has provided name and password credentials directly
        //     into the client application's user interface, and the client application is using
        //     those to acquire an "access_token" and optional "refresh_token". If the web application
        //     supports the resource owner credentials grant type it must validate the context.Username
        //     and context.Password as appropriate. To issue an access token the context.Validated
        //     must be called with a new ticket containing the claims about the resource owner
        //     which should be associated with the access token. The application should take
        //     appropriate measures to ensure that the endpoint isn’t abused by malicious callers.
        //     The default behavior is to reject this grant type. See also http://tools.ietf.org/html/rfc6749#section-4.3.2
        //
        // Parameters:
        //   context:
        //     The context of the event carries information in and results out.
        //
        // Returns:
        //     Task to enable asynchronous execution
        public virtual Task GrantResourceOwnerCredentials(OAuthGrantResourceOwnerCredentialsContext context);
        //
        // Summary:
        //     Called to determine if an incoming request is treated as an Authorize or Token
        //     endpoint. If Options.AuthorizeEndpointPath or Options.TokenEndpointPath are assigned
        //     values, then handling this event is optional and context.IsAuthorizeEndpoint
        //     and context.IsTokenEndpoint will already be true if the request path matches.
        //
        // Parameters:
        //   context:
        //     The context of the event carries information in and results out.
        //
        // Returns:
        //     Task to enable asynchronous execution
        public virtual Task MatchEndpoint(OAuthMatchEndpointContext context);
        //
        // Summary:
        //     Called at the final stage of a successful Token endpoint request. An application
        //     may implement this call in order to do any final modification of the claims being
        //     used to issue access or refresh tokens. This call may also be used in order to
        //     add additional response parameters to the Token endpoint's json response body.
        //
        // Parameters:
        //   context:
        //     The context of the event carries information in and results out.
        //
        // Returns:
        //     Task to enable asynchronous execution
        public virtual Task TokenEndpoint(OAuthTokenEndpointContext context);
        //
        // Summary:
        //     Called for each request to the Authorize endpoint to determine if the request
        //     is valid and should continue. The default behavior when using the OAuthAuthorizationServerProvider
        //     is to assume well-formed requests, with validated client redirect URI, should
        //     continue processing. An application may add any additional constraints.
        //
        // Parameters:
        //   context:
        //     The context of the event carries information in and results out.
        //
        // Returns:
        //     Task to enable asynchronous execution
        public virtual Task ValidateAuthorizeRequest(OAuthValidateAuthorizeRequestContext context);
        //
        // Summary:
        //     Called to validate that the origin of the request is a registered "client_id",
        //     and that the correct credentials for that client are present on the request.
        //     If the web application accepts Basic authentication credentials, context.TryGetBasicCredentials(out
        //     clientId, out clientSecret) may be called to acquire those values if present
        //     in the request header. If the web application accepts "client_id" and "client_secret"
        //     as form encoded POST parameters, context.TryGetFormCredentials(out clientId,
        //     out clientSecret) may be called to acquire those values if present in the request
        //     body. If context.Validated is not called the request will not proceed further.
        //
        // Parameters:
        //   context:
        //     The context of the event carries information in and results out.
        //
        // Returns:
        //     Task to enable asynchronous execution
        public virtual Task ValidateClientAuthentication(OAuthValidateClientAuthenticationContext context);
        //
        // Summary:
        //     Called to validate that the context.ClientId is a registered "client_id", and
        //     that the context.RedirectUri a "redirect_uri" registered for that client. This
        //     only occurs when processing the Authorize endpoint. The application MUST implement
        //     this call, and it MUST validate both of those factors before calling context.Validated.
        //     If the context.Validated method is called with a given redirectUri parameter,
        //     then IsValidated will only become true if the incoming redirect URI matches the
        //     given redirect URI. If context.Validated is not called the request will not proceed
        //     further.
        //
        // Parameters:
        //   context:
        //     The context of the event carries information in and results out.
        //
        // Returns:
        //     Task to enable asynchronous execution
        public virtual Task ValidateClientRedirectUri(OAuthValidateClientRedirectUriContext context);
        //
        // Summary:
        //     Called for each request to the Authorize endpoint to determine if the request
        //     is valid and should continue. The default behavior when using the OAuthAuthorizationServerProvider
        //     is to assume well-formed requests, with validated client credentials, should
        //     continue processing. An application may add any additional constraints.
        //
        // Parameters:
        //   context:
        //     The context of the event carries information in and results out.
        //
        // Returns:
        //     Task to enable asynchronous execution
        public virtual Task ValidateTokenRequest(OAuthValidateTokenRequestContext context);



        // we have override only two from the above virtual method present in base class
        public override async Task ValidateClientAuthentication(OAuthValidateClientAuthenticationContext context)
        {          
            context.Validated();
        }

        public override async Task GrantResourceOwnerCredentials(OAuthGrantResourceOwnerCredentialsContext context)
        {

            context.Validated(new ClaimsIdentity(context.Options.AuthenticationType));

            if (context.UserName == "umeshs@chetu.com" && context.Password == "Chetu@123")
            
            {
                
                context.Validated(new ClaimsIdentity(context.Options.AuthenticationType));
            }
            else
            {
                context.SetError("invalid_grant", "The user name or password is incorrect.");
               
                return;
            }
        }
    }


3).
   public class TokenTestController : ApiController
    {
        [Authorize]
        public IHttpActionResult Authorize()
        {
            return Ok("Authorized");
        }
    }


4).[assembly: OwinStartup(typeof(ApiWithOwin.Startup))]
namespace ApiWithOwin
{
    public class Startup
    {
        public void Configuration(IAppBuilder app)
        {
            ConfigureOAuth(app);

            HttpConfiguration config = new HttpConfiguration();
            WebApiConfig.Register(config);
            app.UseCors(CorsOptions.AllowAll);
            app.UseWebApi(config);
        }

        public void ConfigureOAuth(IAppBuilder app)
        {
            //Options provides information needed to control Authorization Server middleware behavior
            OAuthAuthorizationServerOptions AOuthServerOptions = new OAuthAuthorizationServerOptions
            {
                TokenEndpointPath = new PathString("/token"),
                Provider = new SimpleAuthorizationServerProvider(),
                AccessTokenExpireTimeSpan = TimeSpan.FromMinutes(1),
                // In production mode set AllowInsecureHttp = false
                AllowInsecureHttp = true
            };

            // Enable the application to use bearer tokens to authenticate users
            app.UseOAuthBearerTokens(AOuthServerOptions);
        }
    }
}





Qns 91: What is Application pool?
ans: 
Application pools allow you to isolate your applications from one another, 
even if they are running on the same server. 
This way, if there is an error in one app, it won't take down other applications.

Additionally, applications pools allow you to separate different apps which require different levels of security.
https://www.c-sharpcorner.com/UploadFile/225740/introduction-to-application-pool-in-iis/





Qns 92: different between repeaters and grid view in asp .net?
ans: 

Difference between DataList and Repeater:

DataList	                                                Repeater
1). Rendered as Table.	                                        Template driven.
2). Automatically generates columns from the data source.	This features is not supported.
3). Selection of row is supported.	                        Selection of row is not supported.
4). Editing of contents is supported.	                        Editing of contents is not supported.
5). You can arrange data items horizontally 	                This features is not supported.
  or vertically in DataList by using property RepeatDirection.
6). Performance is slow as compared to Repeater	                This is very light weight and fast data control among all the data control.


Difference between GridView and Repeater:

GridView	                                                 Repeater
It was introduced with Asp.Net 2.0.	                         It was introduced with Asp.Net 1.0.
Rendered as Table.	                                         Template driven.
Automatically generates columns from the data source.	         This features is not supported.
Selection of row is supported.	                                 Selection of row is not supported.
Editing of contents is supported.	                         Editing of contents is not supported.
Built-in Paging and Sorting is provided.	                 You need to write custom code.
Supports auto format or style features.	                         This has no this features.
Performance is very slow as compared to Repeater.	         This is very light weight and fast data control among all the data control.

Difference between GridView and DataList:

GridView	                                                 DataList
It was introduced with Asp.Net 2.0.	                         It was introduced with Asp.Net 1.0.
Built-in Paging and Sorting is provided.	                 You need to write custom code.
Built-in supports for Update and Delete operations.	         Need to write code for implementing Update and Delete operations.
Supports auto format or style features.	                         This features is not supported.
RepeatDirection property is not supported.	                 You can arrange data items horizontally or vertically in DataList by using property RepeatDirection.
Doesn’t support customizable row separator.	                 Supports customizable row separator by using SeparatorTemplate.
Performance is slow as compared to DataList.	                 Performance is fast is compared to GridView.




Qns 93: How to keep the value of viewbag if redirection occur and define mvc life cycle?


Qns 94: difference between arrayList and Dictionary?
ans: arrayList is non generic collection and Dictionary is generic collection


Note: 
List can hold duplicate objects

ArrayList is just for compatibility with older versions of the framework where IList didn't exist

Dictionary is used to store pairs of key/value. You cannot have duplicate keys.

Hashtable is basically a List with no possibility of duplicates (and better performance in some scenarios)

Stack stores objects in order they were added (through Push()), and when you retrieve an object (through Pop()) 
it is removed from the stack in a LIFO manner.

Queue quite similar to a Stack except it is FIFO.






Qns 95: how to pass list<int> or list<string> to the collection/ dropdown/comboBox




Qns 96: what is the access modifier for abstract class default constructor?
ans: protected



Qns 97: can we customized network code ?
ans: 
look at the scenrio:

 enum CustomEnum
    {
        zero,
        one,
        two,
        three,
        four,
        five
    }

 var res = (CustomEnum) 2; 
// res= two
 var res = (CustomEnum) 20; 
// res= 20
var res = (CustomEnum) 55; 
// res= 55

by knowing that fact we can customized network code as below:

According to C# specification:
The set of values that an enum type can take on is not limited by its enum members. 
In particular, any value of the underlying type of an enum can be cast to the enum type 
and is a distinct valid value of that enum type

Therefore you can cast status code 422 to HttpStatusCode.

Example controller:

using System.Net;
using System.Net.Http;
using System.Web.Http;

namespace CompanyName.Controllers.Api
{
    [RoutePrefix("services/noop")]
    [AllowAnonymous]
    public class NoOpController : ApiController
    {
        [Route]
        [HttpGet]
        public IHttpActionResult GetNoop()
        {
            return new System.Web.Http.Results.ResponseMessageResult(
                Request.CreateErrorResponse(
                    (HttpStatusCode)422,
                    new HttpError("Something goes wrong")
                )
            );
        }
    }
}


example 2: 

        public HttpStatusCode Put (int id, [FromBody]Employee emp)
        {
            using (var db = new Angular_2_DBEntities ()) {

                var tblEmployee = db.Employee.Where (x => x.id == id).FirstOrDefault ();

                tblEmployee.email = emp.email;
                tblEmployee.salary = emp.salary;
                tblEmployee.name = emp.name;
                tblEmployee.gender = emp.gender;
                tblEmployee.code = emp.code;
                tblEmployee.dob = emp.dob;
                tblEmployee.modifyDateTime = DateTime.Now;

                db.SaveChanges ();

                //return (HttpStatusCode) 625;
                return HttpStatusCode.OK;
            }
         }


Qns 98: difference between put and post request?
ans: 
https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html
https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
https://httpstatuses.com/
https://www.restapitutorial.com/httpstatuscodes.html

Request verbs(GET, POST, PUT and DELETE): these verbs describe what shouls be done with the resource.
Response Header: contains additional information about the request. ex what type of response is required
Request Body:   contains the data to send to the server.
Response Body:  contains the data send as response from the server.
Response Status Code: provide the client, the status of the request.

Ex Status codes:

1×× Informational
100 Continue
101 Switching Protocols
102 Processing
2×× Success
200 OK
201 Created
202 Accepted
203 Non-authoritative Information
204 No Content
205 Reset Content
206 Partial Content
207 Multi-Status
208 Already Reported
226 IM Used
3×× Redirection
300 Multiple Choices
301 Moved Permanently
302 Found
303 See Other
304 Not Modified
305 Use Proxy
307 Temporary Redirect
308 Permanent Redirect
4×× Client Error
400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Precondition Failed
413 Payload Too Large
414 Request-URI Too Long
415 Unsupported Media Type
416 Requested Range Not Satisfiable
417 Expectation Failed
418 I'm a teapot
421 Misdirected Request
422 Unprocessable Entity
423 Locked
424 Failed Dependency
426 Upgrade Required
428 Precondition Required
429 Too Many Requests
431 Request Header Fields Too Large
444 Connection Closed Without Response
451 Unavailable For Legal Reasons
499 Client Closed Request
5×× Server Error
500 Internal Server Error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 Gateway Timeout
505 HTTP Version Not Supported
506 Variant Also Negotiates
507 Insufficient Storage
508 Loop Detected
510 Not Extended
511 Network Authentication Required
599 Network Connect Timeout Error

Or

 //
    // Summary:
    //     Contains the values of status codes defined for HTTP.
    public enum HttpStatusCode
    {
        //
        // Summary:
        //     Equivalent to HTTP status 100. System.Net.HttpStatusCode.Continue indicates that
        //     the client can continue with its request.
        Continue = 100,
        //
        // Summary:
        //     Equivalent to HTTP status 101. System.Net.HttpStatusCode.SwitchingProtocols indicates
        //     that the protocol version or protocol is being changed.
        SwitchingProtocols = 101,
        //
        // Summary:
        //     Equivalent to HTTP status 200. System.Net.HttpStatusCode.OK indicates that the
        //     request succeeded and that the requested information is in the response. This
        //     is the most common status code to receive.
        OK = 200,
        //
        // Summary:
        //     Equivalent to HTTP status 201. System.Net.HttpStatusCode.Created indicates that
        //     the request resulted in a new resource created before the response was sent.
        Created = 201,
        //
        // Summary:
        //     Equivalent to HTTP status 202. System.Net.HttpStatusCode.Accepted indicates that
        //     the request has been accepted for further processing.
        Accepted = 202,
        //
        // Summary:
        //     Equivalent to HTTP status 203. System.Net.HttpStatusCode.NonAuthoritativeInformation
        //     indicates that the returned metainformation is from a cached copy instead of
        //     the origin server and therefore may be incorrect.
        NonAuthoritativeInformation = 203,
        //
        // Summary:
        //     Equivalent to HTTP status 204. System.Net.HttpStatusCode.NoContent indicates
        //     that the request has been successfully processed and that the response is intentionally
        //     blank.
        NoContent = 204,
        //
        // Summary:
        //     Equivalent to HTTP status 205. System.Net.HttpStatusCode.ResetContent indicates
        //     that the client should reset (not reload) the current resource.
        ResetContent = 205,
        //
        // Summary:
        //     Equivalent to HTTP status 206. System.Net.HttpStatusCode.PartialContent indicates
        //     that the response is a partial response as requested by a GET request that includes
        //     a byte range.
        PartialContent = 206,
        //
        // Summary:
        //     Equivalent to HTTP status 300. System.Net.HttpStatusCode.MultipleChoices indicates
        //     that the requested information has multiple representations. The default action
        //     is to treat this status as a redirect and follow the contents of the Location
        //     header associated with this response.
        MultipleChoices = 300,
        //
        // Summary:
        //     Equivalent to HTTP status 300. System.Net.HttpStatusCode.Ambiguous indicates
        //     that the requested information has multiple representations. The default action
        //     is to treat this status as a redirect and follow the contents of the Location
        //     header associated with this response.
        Ambiguous = 300,
        //
        // Summary:
        //     Equivalent to HTTP status 301. System.Net.HttpStatusCode.MovedPermanently indicates
        //     that the requested information has been moved to the URI specified in the Location
        //     header. The default action when this status is received is to follow the Location
        //     header associated with the response.
        MovedPermanently = 301,
        //
        // Summary:
        //     Equivalent to HTTP status 301. System.Net.HttpStatusCode.Moved indicates that
        //     the requested information has been moved to the URI specified in the Location
        //     header. The default action when this status is received is to follow the Location
        //     header associated with the response. When the original request method was POST,
        //     the redirected request will use the GET method.
        Moved = 301,
        //
        // Summary:
        //     Equivalent to HTTP status 302. System.Net.HttpStatusCode.Found indicates that
        //     the requested information is located at the URI specified in the Location header.
        //     The default action when this status is received is to follow the Location header
        //     associated with the response. When the original request method was POST, the
        //     redirected request will use the GET method.
        Found = 302,
        //
        // Summary:
        //     Equivalent to HTTP status 302. System.Net.HttpStatusCode.Redirect indicates that
        //     the requested information is located at the URI specified in the Location header.
        //     The default action when this status is received is to follow the Location header
        //     associated with the response. When the original request method was POST, the
        //     redirected request will use the GET method.
        Redirect = 302,
        //
        // Summary:
        //     Equivalent to HTTP status 303. System.Net.HttpStatusCode.SeeOther automatically
        //     redirects the client to the URI specified in the Location header as the result
        //     of a POST. The request to the resource specified by the Location header will
        //     be made with a GET.
        SeeOther = 303,
        //
        // Summary:
        //     Equivalent to HTTP status 303. System.Net.HttpStatusCode.RedirectMethod automatically
        //     redirects the client to the URI specified in the Location header as the result
        //     of a POST. The request to the resource specified by the Location header will
        //     be made with a GET.
        RedirectMethod = 303,
        //
        // Summary:
        //     Equivalent to HTTP status 304. System.Net.HttpStatusCode.NotModified indicates
        //     that the client's cached copy is up to date. The contents of the resource are
        //     not transferred.
        NotModified = 304,
        //
        // Summary:
        //     Equivalent to HTTP status 305. System.Net.HttpStatusCode.UseProxy indicates that
        //     the request should use the proxy server at the URI specified in the Location
        //     header.
        UseProxy = 305,
        //
        // Summary:
        //     Equivalent to HTTP status 306. System.Net.HttpStatusCode.Unused is a proposed
        //     extension to the HTTP/1.1 specification that is not fully specified.
        Unused = 306,
        //
        // Summary:
        //     Equivalent to HTTP status 307. System.Net.HttpStatusCode.TemporaryRedirect indicates
        //     that the request information is located at the URI specified in the Location
        //     header. The default action when this status is received is to follow the Location
        //     header associated with the response. When the original request method was POST,
        //     the redirected request will also use the POST method.
        TemporaryRedirect = 307,
        //
        // Summary:
        //     Equivalent to HTTP status 307. System.Net.HttpStatusCode.RedirectKeepVerb indicates
        //     that the request information is located at the URI specified in the Location
        //     header. The default action when this status is received is to follow the Location
        //     header associated with the response. When the original request method was POST,
        //     the redirected request will also use the POST method.
        RedirectKeepVerb = 307,
        //
        // Summary:
        //     Equivalent to HTTP status 400. System.Net.HttpStatusCode.BadRequest indicates
        //     that the request could not be understood by the server. System.Net.HttpStatusCode.BadRequest
        //     is sent when no other error is applicable, or if the exact error is unknown or
        //     does not have its own error code.
        BadRequest = 400,
        //
        // Summary:
        //     Equivalent to HTTP status 401. System.Net.HttpStatusCode.Unauthorized indicates
        //     that the requested resource requires authentication. The WWW-Authenticate header
        //     contains the details of how to perform the authentication.
        Unauthorized = 401,
        //
        // Summary:
        //     Equivalent to HTTP status 402. System.Net.HttpStatusCode.PaymentRequired is reserved
        //     for future use.
        PaymentRequired = 402,
        //
        // Summary:
        //     Equivalent to HTTP status 403. System.Net.HttpStatusCode.Forbidden indicates
        //     that the server refuses to fulfill the request.
        Forbidden = 403,
        //
        // Summary:
        //     Equivalent to HTTP status 404. System.Net.HttpStatusCode.NotFound indicates that
        //     the requested resource does not exist on the server.
        NotFound = 404,
        //
        // Summary:
        //     Equivalent to HTTP status 405. System.Net.HttpStatusCode.MethodNotAllowed indicates
        //     that the request method (POST or GET) is not allowed on the requested resource.
        MethodNotAllowed = 405,
        //
        // Summary:
        //     Equivalent to HTTP status 406. System.Net.HttpStatusCode.NotAcceptable indicates
        //     that the client has indicated with Accept headers that it will not accept any
        //     of the available representations of the resource.
        NotAcceptable = 406,
        //
        // Summary:
        //     Equivalent to HTTP status 407. System.Net.HttpStatusCode.ProxyAuthenticationRequired
        //     indicates that the requested proxy requires authentication. The Proxy-authenticate
        //     header contains the details of how to perform the authentication.
        ProxyAuthenticationRequired = 407,
        //
        // Summary:
        //     Equivalent to HTTP status 408. System.Net.HttpStatusCode.RequestTimeout indicates
        //     that the client did not send a request within the time the server was expecting
        //     the request.
        RequestTimeout = 408,
        //
        // Summary:
        //     Equivalent to HTTP status 409. System.Net.HttpStatusCode.Conflict indicates that
        //     the request could not be carried out because of a conflict on the server.
        Conflict = 409,
        //
        // Summary:
        //     Equivalent to HTTP status 410. System.Net.HttpStatusCode.Gone indicates that
        //     the requested resource is no longer available.
        Gone = 410,
        //
        // Summary:
        //     Equivalent to HTTP status 411. System.Net.HttpStatusCode.LengthRequired indicates
        //     that the required Content-length header is missing.
        LengthRequired = 411,
        //
        // Summary:
        //     Equivalent to HTTP status 412. System.Net.HttpStatusCode.PreconditionFailed indicates
        //     that a condition set for this request failed, and the request cannot be carried
        //     out. Conditions are set with conditional request headers like If-Match, If-None-Match,
        //     or If-Unmodified-Since.
        PreconditionFailed = 412,
        //
        // Summary:
        //     Equivalent to HTTP status 413. System.Net.HttpStatusCode.RequestEntityTooLarge
        //     indicates that the request is too large for the server to process.
        RequestEntityTooLarge = 413,
        //
        // Summary:
        //     Equivalent to HTTP status 414. System.Net.HttpStatusCode.RequestUriTooLong indicates
        //     that the URI is too long.
        RequestUriTooLong = 414,
        //
        // Summary:
        //     Equivalent to HTTP status 415. System.Net.HttpStatusCode.UnsupportedMediaType
        //     indicates that the request is an unsupported type.
        UnsupportedMediaType = 415,
        //
        // Summary:
        //     Equivalent to HTTP status 416. System.Net.HttpStatusCode.RequestedRangeNotSatisfiable
        //     indicates that the range of data requested from the resource cannot be returned,
        //     either because the beginning of the range is before the beginning of the resource,
        //     or the end of the range is after the end of the resource.
        RequestedRangeNotSatisfiable = 416,
        //
        // Summary:
        //     Equivalent to HTTP status 417. System.Net.HttpStatusCode.ExpectationFailed indicates
        //     that an expectation given in an Expect header could not be met by the server.
        ExpectationFailed = 417,
        //
        // Summary:
        //     Equivalent to HTTP status 426. System.Net.HttpStatusCode.UpgradeRequired indicates
        //     that the client should switch to a different protocol such as TLS/1.0.
        UpgradeRequired = 426,
        //
        // Summary:
        //     Equivalent to HTTP status 500. System.Net.HttpStatusCode.InternalServerError
        //     indicates that a generic error has occurred on the server.
        InternalServerError = 500,
        //
        // Summary:
        //     Equivalent to HTTP status 501. System.Net.HttpStatusCode.NotImplemented indicates
        //     that the server does not support the requested function.
        NotImplemented = 501,
        //
        // Summary:
        //     Equivalent to HTTP status 502. System.Net.HttpStatusCode.BadGateway indicates
        //     that an intermediate proxy server received a bad response from another proxy
        //     or the origin server.
        BadGateway = 502,
        //
        // Summary:
        //     Equivalent to HTTP status 503. System.Net.HttpStatusCode.ServiceUnavailable indicates
        //     that the server is temporarily unavailable, usually due to high load or maintenance.
        ServiceUnavailable = 503,
        //
        // Summary:
        //     Equivalent to HTTP status 504. System.Net.HttpStatusCode.GatewayTimeout indicates
        //     that an intermediate proxy server timed out while waiting for a response from
        //     another proxy or the origin server.
        GatewayTimeout = 504,
        //
        // Summary:
        //     Equivalent to HTTP status 505. System.Net.HttpStatusCode.HttpVersionNotSupported
        //     indicates that the requested HTTP version is not supported by the server.
        HttpVersionNotSupported = 505
    }







Both are used for data transmission between client to server, but there are subtle differences between them, which are:

PUT You can think of similar to "UPDATE STUDENT SET address = "abc" where id="123";
POST You can think of something like "INSERT INTO STUDENT(name, address) VALUES ("abc", "xyzzz");
Student Id is auto generated.

With PUT, if the same query is executed multiple times or one time, 
the STUDENT table state remains the same. i.e. PUT method is idempotent.

In case of POST, if the same query is executed multiple times then multiple Student records get created in the database 
and the database state changes on each execution of an "INSERT" query.

Analogy:
PUT i.e. take and put where it was.
POST as send mail in post office.

Overview of (some) HTTP methods:

HTTP Method	    Idempotent	Safe
-----------         ----------  ----
OPTIONS	             yes	yes
GET	             yes	yes
HEAD	             yes	yes
PUT	             yes	no
POST	             no	        no
DELETE	             yes	no
PATCH	             no	        no


In General:

POST: Create a row
PUT: update a row
Get: read a row
DELETE:to delete a row



https://social.msdn.microsoft.com/Forums/vstudio/en-US/3a1116db-c8dd-46e6-a895-51b395ebcbb3/web-api-with-multiple-post-methods?forum=wcf
  Configure WEB API controller with Multiple Post Methods:

            //config.Routes.MapHttpRoute(
            //    name: "DefaultApi",
            //    routeTemplate: "api/{controller}/{id}",
            //    defaults: new { id = RouteParameter.Optional }
            //);
            http://localhost:65188/api/controllerName
           
            This does not allow multiple get and post under the web api


            update above one to below one:

            config.Routes.MapHttpRoute (
            name: "DefaultApi",
            routeTemplate: "api/{controller}/{action}/{id}",
            defaults: new { id = RouteParameter.Optional }
            );


           http://localhost:65188/api/controllerName/actionName

           This allow multiple get and post under the web api



Qns 99: can we return something from the finally block?
ans: No, gives compile time error: Control can not leave the body of finally clause.





Qns 100: what is multitasking/multithreading ?
ans: 

example for lock keyword:
The lock keyword ensures that one thread does not enter a critical section of code while another thread is in the critical section. 
If another thread tries to enter a locked code, it will wait, block, until the object is released.



// using System.Threading;

class Account
{
    private Object thisLock = new Object();
    int balance;

    Random r = new Random();

    public Account(int initial)
    {
        balance = initial;
    }

    int Withdraw(int amount)
    {

        // This condition never is true unless the lock statement
        // is commented out.
        if (balance < 0)
        {
            throw new Exception("Negative Balance");
        }

        // Comment out the next line to see the effect of leaving out 
        // the lock keyword.
        lock (thisLock)
        {
            if (balance >= amount)
            {
                Console.WriteLine("Balance before Withdrawal :  " + balance);
                Console.WriteLine("Amount to Withdraw        : -" + amount);
                balance = balance - amount;
                Console.WriteLine("Balance after Withdrawal  :  " + balance);
                return amount;
            }
            else
            {
                return 0; // transaction rejected
            }
        }
    }

    public void DoTransactions()
    {
        for (int i = 0; i < 100; i++)
        {
            Withdraw(r.Next(1, 100));
        }
    }
}

class Test
{
    static void Main()
    {
        Thread[] threads = new Thread[10];
        Account acc = new Account(1000);
        for (int i = 0; i < 10; i++)
        {
            Thread t = new Thread(new ThreadStart(acc.DoTransactions));
            threads[i] = t;
        }
        for (int i = 0; i < 10; i++)
        {
            threads[i].Start();
        }
        
        //block main thread until all other threads have ran to completion.
        foreach (var t in threads)
            t.Join();            
    }
}



what is race condition?
ans: A race condition occurs when two or more threads can access shared data and they try to change it at the same time.
     Note: Race conditions can be avoided by employing some sort of locking mechanism before the code that accesses the shared resource.   

Example: 
Problems often occur when one thread does a "check-then-act" (e.g. "check" if the value is X, then "act" to 
do something that depends on the value being X) and another thread does something to the value in between the "check" and the "act". E.g:

if (x == 5) // The "Check"
{
   y = x * 2; // The "Act"

   // If another thread changed x in between "if (x == 5)" and "y = x * 2" above,
   // y will not be equal to 10.
}

The point being, y could be 10, or it could be anything, depending on whether another thread changed x in between the check and act. 
You have no real way of knowing.

In order to prevent race conditions from occurring, you would typically put a lock around the shared data to ensure only one thread
 can access the data at a time. This would mean something like this:

// Obtain lock for x
if (x == 5)
{
   y = x * 2; // Now, nothing can change x until the lock is released. 
              // Therefore y = 10
}
// release lock for x



what is dead lock condition ?
-----------------------------
https://www.c-sharpcorner.com/UploadFile/1d42da/deadlock-in-threading-in-C-Sharp/
https://blogs.msdn.microsoft.com/mohamedg/2010/01/29/how-to-use-locks-and-prevent-deadlocks/

ans:  Introduction

A deadlock is a situation where an application locks up because two or more activities are waiting for each other to finish. 
This occurs in multithreading software where a shared resource is locked by one thread and another thread is waiting to access it 
and something occurs so that the thread holding the locked item is waiting for the other thread to execute.

First, it's important to understand what a deadlock among threads is and the conditions that lead to one. 
Many OS course textbooks will cite the four conditions necessary for a deadlock to occur:

A limited number of a particular resource. In the case of a monitor in C# (what you use when you employ the lock keyword), 
this limited number is one, since a monitor is a mutual-exclusion lock (meaning only one thread can own a monitor at a time).
The ability to hold one resource and request another. In C#, this is akin to locking on one object and 
then locking on another before releasing the first lock, for example:
lock(a)
   {
         lock(b)
         {
            ....
         }
   }

No preemption capability. In C#, this means that one thread can't force another thread to release a lock.
A circular wait condition. This means that there is a cycle of threads, each of which is waiting for the next to release a resource before it can continue.
If any one of these conditions is not met, deadlock is not possible. We can avoid all four condition by the followings:

The first condition is inherent to what a monitor is, so if you're using monitors, this one is set in stone.
The second condition could be avoided by ensuring that you only ever lock one object at a time, but that's frequently not a feasible requirement in a large software project.
The third condition could possibly be avoided in the MicrosoftÂ® .NET Framework by aborting or interrupting the thread holding the resource your thread requires, but a) that would require knowing which thread owned the resource, and b) that's an inherently dangerous operation .
To further illustrate how a deadlock might occur, imagine the following sequence of events:

Thread 1 acquires lock A.
Thread 2 acquires lock B.
Thread 1 attempts to acquire lock B, but it is already held by Thread 2 and thus Thread 1 blocks until B is released.
Thread 2 attempts to acquire lock A, but it is held by Thread 1 and thus Thread 2 blocks until A is released.
At this point, both threads are blocked and will never wake up. The following C# code demonstrates this situation.

object lockA = new object();
object lockB = new object(); 
        Thread 1 void t1() 
        { 
            lock (lockA) 
            { 
                lock (lockB)
                { 
                    /* ... */
                } 
            } 
        } 
        Thread 2 void t2() 
        { 
            lock (lockB)
            { 
                lock (lockA)
                   { 
                    /* ... */
                   } 
            } 
        }

We have another code which demonstrate the deadlock condition as:

using System;
using System.Threading;
namespace deadlockincsharp
{
public class Akshay
    {
        static readonly object firstLock = new object();
        static readonly object secondLock = new object();
        static void ThreadJob()
        {
            Console.WriteLine("\t\t\t\tLocking firstLock");
            lock (firstLock)
            {
                Console.WriteLine("\t\t\t\tLocked firstLock");
                // Wait until we're fairly sure the first thread
                // has grabbed secondLock
                Thread.Sleep(1000);
                Console.WriteLine("\t\t\t\tLocking secondLock");
                lock (secondLock)
                {
                    Console.WriteLine("\t\t\t\tLocked secondLock");
                }
                Console.WriteLine("\t\t\t\tReleased secondLock");
            }
            Console.WriteLine("\t\t\t\tReleased firstLock");
        }
        static void Main()
        {
            new Thread(new ThreadStart(ThreadJob)).Start();
            // Wait until we're fairly sure the other thread
            // has grabbed firstLock
            Thread.Sleep(500);
            Console.WriteLine("Locking secondLock");
            lock (secondLock)
            {
                Console.WriteLine("Locked secondLock");
                Console.WriteLine("Locking firstLock");
                lock (firstLock)
                {
                    Console.WriteLine("Locked firstLock");
                }
                Console.WriteLine("Released firstLock");
            }
            Console.WriteLine("Released secondLock");
            Console.Read();
        }       
    }
}




example double-check-locking-in-singleton-pattern for single ton:
-------------------------------------------------------------------

https://stackoverflow.com/questions/5950418/double-check-locking-in-singleton-pattern
Multithreaded Singleton : The best approach to use double check locking

public sealed class Singleton
{
   private static volatile Singleton _instance;
   private static readonly object InstanceLoker= new Object();

   private Singleton() {}

   public static Singleton Instance
   {
      get 
      {
         if (_instance == null) 
         {
            lock (InstanceLoker) 
            {
               if (_instance == null) 
                  _instance = new Singleton();
            }
         }

         return _instance;
      }
   }
}





Qns 101: define data type in c#
ans: value type and reference type

Qns 102: what is Signal R?
Qns 103: what is remoting?



Qns: 104 difference between webforms and mvc?
ans: 
https://www.codeproject.com/Articles/821275/Webforms-vs-MVC-and-Why-MVC-is-better

1)
In Asp.Net Web Form, Web Forms(ASPX) i.e. views are tightly coupled to Code behind(ASPX.CS) i.e. logic.	
In Asp.Net MVC, Views and logic are kept separately.

i.e 'seperation of concern' is big advantage provided by MVC
ASP.NET MVC is a Microsoft’s one more Web application framework designed with separation of concerns and testability in mind.


2).
View based solution for Action based requirement

Websites at the end of the day are used by end users. 
End users come with a specific purpose to a website and they communicate their purpose by actions. 
For instance if somebody comes to shop on a shopping portal he will communicate his purposeusing actions like:-

Buy product.
Print invoice

Now these actions are communicated by button click , 
right click or through a browser URL etc. 
Due to this action based structure HTTP protocol was chosen for Web because it had actions like POST,GET,PUT,DELETE
etc which can communicate the purpose of end users more clearly. That also makes REST a popular way of 
addressing end user request. So logically if we can map these actions to methods / functions of our program that would make more sense 
and also keep the architecture simple.

But Microsoft had no way out, they wanted to support RAD concept or we can term it as visual programming concept, 
so they ended up with a view based solution for an action based structure.



So flow of request went something WEIRD like this for web forms( for visual’s see the above diagram):-

End user sends a request with action like HTTP POST / GET etc.
IIS webserver maps this request to a view.
View invokes the page life cycle, walks through events and then INVOKES THE APPROPRIATE ACTION.
Finally action put’s the RESULT IN HTML format and sends it to the end user browser.

Microsoft ended with a view based architecture for an action based requirement. 
So the architecture itself was not fitting logically to the end user’s action based approach. 
In other words if the end user sends a “Buy” action it first comes to a view like “Shopping.aspx” 
who in turn kicks of “Shopping.aspx.cs” which executes a complicated page life cycle 
which in turn executes the action which will fulfill the request of the end user.



This is like hitting the bush. The end requests aregetting mapped to the actual action after a complicated page life cycle is completed. 
So how about we make itan action oriented architecturerather thanview oriented.
 Or I can rephrase it “HOW CAN WE MAKE ACTION FIRST STRUCTURE RATHER THAN A VIEW FIRST STRUCTURE ?”.

So how about hitting the action first and then the action picks up view. 
This would make the flow more logical and clear. That’s what exactly MVC architecture does. The first hit comes to an action which belongs in to a controller and then controller invokes the view with appropriate model.


3). Problem 2:- Side effects of bad architecture: - Tight coupling
ans: Once you start with a wrong architecture you end up adjusting things and then you end up with serious side effects. 
In this case the same was happening. The behind code which looks physically different in different files was never actually decoupled 
i.e. ASPX.CS cannot be separated from ASPX.
    WebForm1.apsx
     WebForm1.apsx.cs
     WebForm1.apsx.designer.cs

In simple words I cannot attach “Customer.aspx.cs” with “CustomerDetailed.aspx” easily. 
The behind code is tightly coupled with view. It is not reusable.


4). Problem 3:- HTML is not the only response type
Because of the tight coupling between view and code behind even the response type is fixed in webform ,
its by default HTML. If you wish to change it you need to play around with Content-type and “Response.End” methods etc which is quiet tedious.

If we create “Action” first structure then the action has all the luxury in the world to decide what kind of response type should go out.
This makes our system more flexible in terms of same action with different outputs.

Below is a simple MVC action code which send’s JSON or HTML result depending on the value passed to the action. 
This kind of flexibility is difficult to achieve with webformview’s because they are meant to emit only HTML.

Hide   Copy Code
public ActionResult Index(string viewType)
{
            if (viewType == "JSON")
            {
                return Json(new Customer(), JsonRequestBehavior.AllowGet);
            }
            else
            {
                return View("DisplayCustomer", new Customer());
            }
}


So to change from a view based architecture to an action based MVC architecture we need to do the following structural changes 
( The above image gives a visual view of the same):-

Move the behind code in to a controller class with all the events converted in to methods which can be termed as actions.
The middle layer becomes the model which provides data and business logic.
The view just does display,positioning and layouting.
The DAL and other layers do not change a lot as they have no connection with the behind code issue directly.


So with MVC architecture we have the below three step flow:-

End user sends his request application. Application routes the request to the Controller. 
Controller is a logical entity which groups actions together. Controller maps that request to a particular action.
Now action has two tasks to do first it needs to access appropriate data depending on the action and 
second that data has to be connected to the proper view. Action creates the model object and connects the model to the view 
to send the final response.



https://www.codeproject.com/Articles/528117/WebForms-vs-MVC

What is MVC?
MVC is an architectural pattern which is has been around for sometimes now.
Many are using it including Java. It’s not new concept which Microsoft brought it up. ASP.NET MVC is something we should talk about. 
But prior to that lets clear some terminologies including MVC.


Patterns - In simple words Pattern is a solution to a problem in a context.

Architectural Patterns - Architectural Pattern is something which solves our problem at sub system level or in short module level. It deals with the problem related 
to architecture of a project. It tells us how we can divide our systems and especially why. We make Class libraries, Components, Web services to solve the problem.

MVC When we talk about application we will be having input logic, business logic and UI logic and MVC is an architectural pattern which let us develop an application 
having loosely coupling between each of these elements.
The main intention behind MVC pattern is separation of concerns. It makes presentation or UI ignorant of business and user interaction logic.
According to MVC system should be divided as M (Model), V (View) and C (Controller).
	
Model is considered as smart and handles the Business rules, logic and data and will be independent of other parts of MVC (controller and View).
Controller receives and dispatches the request in short it handles the user interaction and input logic. It knows about both Model and View.
A view is considered as dumb and is an output representation of model data. It may be an excel sheet, a web page showing list of records or just a simple text. View knows about only Model.



What is ASP.NET MVC?


ASP.NET MVC is a Microsoft’s one more Web application framework designed with 'separation of concerns' and 'testability' in mind. 
It is built on CLR and completely based on MVC architecture and so we think in terms of controllers and Views. 
ASP.NET MVC doesn’t have support for ViewState and server controls, so we get feel of old web here. 

Let’s talk about Advantages and disadvantages of ASP.NET MVC

Advantages:

Project architecture -
One of the advantages of using ASP.NET MVC is it enforces separation of concerns. So there is very less chances of getting things more complex.
Test Driven development and Reusability –
In MVC controller is a separate class so automatic testing is possible featuring Test Driven Development.
Controllers are not bound to any specific view and so can be reused for multiple views.

Performance - ASP.NET MVC don’t have support for view state, so there will not be any automatic state management which reduces the page size and so gain the performance.
Full control over HTML - ASP.NET MVC doesn’t support server controls, only option available is using html input controls, so we will be sure about final html rendered at the end. We will also be aware about 'id' of every element. And so integration of ASP.NET MVC application with third party JavaScript libraries like jQuery becomes easy.
Support for parallel development - In ASP.NET MVC layers are loosely coupled with each other, so one developer can work on Controller ,at the same time other on View and third developer on Model. This is called parallel development.
SEO, URL routing and REST - Rich routing features lets treat every URL as a resource supporting RESTful interfaces.


Also user-friendly and readable URL improves SEO.

Extensibility - ASP.NETMVC supports multiple view engines like aspx, razor and if required we can create our own.
Existing ASP.NET Features – ASP.NET MVC framework is built on top of matured ASP.NET framework and thus provides developer to use many good features such as forms authentication, windows authentication, caching, session and profile state management etc.


Disadvantages:
More learning effort - Absence of event driven programming model and ViewState makes ASP.NET MVC a very difficult framework for developers with no or little experience in web application development.
How ASP.NET MVC works


User makes the request for some resource in server (by putting some URL in the browser).
Request comes to controller first (routing engine is the one who is responsible for deciding which request will be handled by which controller. 
In this article we won’t talk in depth about this behavior).

Controller if required talk to model for data.
Model operates on database (or on some other data sources) and return data (in form of business objects) to controller.
Controller chooses the appropriate view (like say Customer view which will may contain some html tables, drop downs, textboxes…).
Controller passes the data (model data retrieved in step 4) to chosen view(in step 5), where data will be populated as per convenience.
Controller sends back view to the user.
This was for get request, same happens for post. Only instead of putting URL in the browser user will do some action on already requested page and flow start with the controller. Actions like clicking button, changing drop down value etc.



Why ASP.NET Web Forms and Why ASP.NET MVC?
Each can be the “best choice” for a particular solution depending on the requirements of the application and the background of the team members involved. 
What to choose and when has more to do with business prospective than which one is better than other. 
When facing a decision to choose between ASP.NET Web Forms or ASP.NET MVC it is important to know that neither technology is meant to replace the other.


Two important factors you should consider while making the choice is
Rapid application development - If you want to develop anything rapidly ASP.NET Web Forms is the only chance you are having, you can’t even consider for ASP.NET MVC for RAD. (Reasons for RAD may be anything like client is not paying too much, or application is going to be used for only one or two months and won’t require much maintenance.)
Unit Testing - If automatic unit testing is most important factor for you MVC will be best for you.
Other than these, what you can do is, write down all your project requirement and try to compare them with Pros and Cons of both Web Forms and MVC and if possible try to ask yourself following questions and point MVC and Web Forms accordingly



Does your team have good experience with Web Forms or Windows Forms?
Well, if yes then probably learning ASP.NET MVC is going to be a tedious task for team, because developers have been used to with ViewState and event driven programming by now and migration is going to be a difficult task.1 point to Web Forms.

Does your team have good experience with ASP.NET MVC?
If yes ASP.NET MVC get 1 point

Does your team have experience on ASP or non-Microsoft technologies such as android, ios, JSP, ROR, PHP?
If you have been JSP or ASP developer prior then you might be familiar with HTTP get and Post and even u might have hands on with 
MVC because most of them use MVC by default. It gives 1 point to ASP.NET MVC.

Is JavaScript going to be used extensively?
If Yes, MVC gets the point because you get complete control over HTML. 1 point ASP.NET MVC.

Looking for good performance?
With no support for ViewState ASP.NET MVC provides good performance gain over traditional ASP.NET Web Forms.1 point ASP.NET MVC.

Planning to reuse the same input logic?
If yes stick with MVC.








Qns 105: State Management In ASP.NET MVC
ans: As we all know, HTTP is a stateless protocol, i.e., each HTTP request does not know about the previous request. 
If you are redirecting from one page to another page, then you have to maintain or persist your data so that you can access it further. 
To do this, there were many techniques available in ASP.NET like ViewState, SessionState, ApplicationState etc.

ASP.NET MVC also provides state management techniques that can help us to maintain the data when redirecting from one page to other page or in the same page 
after reloading. There are several ways to do this in ASP.NET MVC -

 Hidden Field
 Cookies
 Query String
 ViewData
 ViewBag
 TempData


Client-side options are:
------------------------

  Hidden fields
  Cookies
  Query strings

Server-side options are:
-------------------------
  ViewData
  ViewBag
  TempData



The above objects help us to persist our data on the same page or when moving from “Controller” to “View” or “Controller” to Controller”.
Let us start practical implementation of these so that we can understand in a better way.

Hidden Field:
--------------
It is not new, we all know it from HTML programming. Hidden field is used to hide your data on client side. It is not directly visible to the user on UI but we can see the value in the page source. So, this is not recommended if you want to store a sensitive data. It’s only used to store a small amount of data which is frequently changed.

The following code is storing the Id of employee and its value is 1001.

@Html.HiddenFor(x=>x.Id)  
If you open the page source code for that page in the browser, you will find the following line of code, which is nothing but the HTML version of the above code with value. Just focus on last three attributes.

<input data-val="true" data-val-number="The field Id must be a number." data-val-required="The Id field is required." id="Id" name="Id" type="hidden" value="1001" />  

Cookies:
--------------
Cookies are used for storing the data but that data should be small. It is like a small text file where we can store our data. The good thing is that a cookie is created on client side memory in the browser. Most of the times, we use a cookie for storing the user information after login with some expiry time. Basically, a cookie is created by the server and sent to the browser in response. The browser saves it in client-side memory.

We can also use cookies in ASP.NET MVC for maintaining the data on request and respond. It can be like the below code.

HttpCookie cookie = new HttpCookie("TestCookie");  
cookie.Value = "This is test cookie";  
this.ControllerContext.HttpContext.Response.Cookies.Add(cookie);  
Here, we have created one cookie and named it as “TestCookie”. We can create multiple cookies and add with Response. For getting the value from an existing cookie, we first need to check that the cookie is available or not; then, we can access the value of the cookie.

if (this.ControllerContext.HttpContext.Request.Cookies.AllKeys.Contains("TestCookie"))  
{  
  HttpCookie cookie = this.ControllerContext.HttpContext.Request.Cookies["TestCookie"];  
  
              ViewBag.CookieMessage = cookie.Value;  
}  
Cookies are all depended on expiry, you can create a cookie on one action method in a controller and it will save on the client side and can be accessed in another action method easily.

Query String:
--------------

In ASP.NET, we generally use a query string to pass the value from one page to the next page. Same we can do in ASP.NET MVC as well.

http://localhost:49985/home/editemployee?name=TestValue

I am making one request with the above URL. You can see that in this, I am passing name’s value as a query string and that will be accessible on “EditEmployee” action method in “Home” controller as the following image shows.

ASP.NET
ViewData:
--------------

It helps us to maintain your data when sending the data from Controller to View. It is a dictionary object and derived from ViewDataDictionary. As it is a dictionary object, it takes the data in a key-value pair.

Once you create ViewData object, pass the value, and make redirection; the value will become null. The data of ViewData is not valid for next subsequent request. Take care of two things when using ViewData, first, check for null and second, check for typecasting for complex data types.

public ActionResult Index()  
        {  
            Employee emp = new Employee()  
            {  
                Id = 1001,  
                Name = "Mukesh Kumar",  
                Address = "New Delhi",  
                Age = 25  
            };  
              
            ViewData["Message"] = "This is ViewData";  
            ViewData["Emp"] = emp;  
  
            return View();  
        }  
The above code contains two ViewData dictionary objects - ViewData["Message"] and ViewData["Emp"]. The first one is a simple string value but the next one contains complex employee data. When the View is going to render, we need to first check the ViewData for null and if it is not, then we can get the value.

@{  
    ViewBag.Title = "Home Page";  
}  
  
<div class="row">  
    <div class="col-md-4">  
        <h2>Employee Details</h2>  
        <br />  
        <p>  
            @if(ViewData["Message"] !=null)  
            {  
                <b>@ViewData["Message"].ToString();</b>  
            }  
        </p>  
        <br />  
        @if (ViewData["Emp"] != null)  
        {  
  
            var emp = (MVCStateManagement.Models.Employee)ViewData["Emp"];  
            <table>  
                <tr>  
                    <td>  
                        Name :  
                    </td>  
                    <td>  
                        @emp.Name  
                    </td>  
                </tr>  
                <tr>  
                    <td>  
                        Address :  
                    </td>  
                    <td>  
                        @emp.Address  
                    </td>  
                </tr>  
                <tr>  
                    <td>  
                        Age :  
                    </td>  
                    <td>  
                        @emp.Age  
                    </td>  
                </tr>  
            </table>              
        }  
    </div>  
</div>  
ASP.NET

ViewBag:
--------------

The ViewBag’s task is same as that of ViewData. It is also used to transfer the data from Controller to View. However, the only difference is that ViewBag is an object of Dynamic property introduced in C# 4.a. It is a wrapper around ViewData. If you use ViewBag rather than ViewData, you will not have to do typecasting with the complex objects and do not need to check for null.

If we consider the same above code with ViewBag, the output will be same.

public ActionResult Index()  
        {  
            Employee emp = new Employee()  
            {  
                Id = 1001,  
                Name = "Mukesh Kumar",  
                Address = "New Delhi",  
                Age = 25  
            };  
              
            ViewBag.Message = "This is ViewBag";  
            ViewBag.Emp = emp;  
  
            return View();  
        }  
On View, you have to change ViewData with ViewBag.

@{  
    ViewBag.Title = "Home Page";  
}  
  
<div class="row">  
    <div class="col-md-4">  
        <h2>Employee Details</h2>  
        <br />  
        <p>  
  
            <b>@ViewBag.Message</b>  
  
        </p>  
        <br />  
        @{  
            var emp = ViewBag.Emp;  
            <table>  
                <tr>  
                    <td>  
                        Name :  
                    </td>  
                    <td>  
                        @emp.Name  
                    </td>  
                </tr>  
                <tr>  
                    <td>  
                        Address :  
                    </td>  
                    <td>  
                        @emp.Address  
                    </td>  
                </tr>  
                <tr>  
                    <td>  
                        Age :  
                    </td>  
                    <td>  
                        @emp.Age  
                    </td>  
                </tr>  
            </table>  
        }  
    </div>  
</div>  
ASP.NET

Note

If you are using ViewData that is not defined on Controller, then it will throw an error; but with ViewBag, it will not.
Do not use ViewBag and ViewData with the same name, otherwise, only one message will display. See the following code in the controller is using both ViewData and ViewBag with same name “Message”.
public ActionResult Index()  
        {  
            ViewData["Message"] = "This is ViewData";  
            ViewBag.Message = "This is ViewBag";              
  
            return View();  
        }  
On view defined both as following.  
        <b>@ViewBag.Message</b>  
            @if(ViewData["Message"]!=null)  
            {  
                ViewData["Message"].ToString();  
     }  
The output will show only one message and that will be the last one [in this case, message will be “This is ViewBag”].

TempData:
--------------

TempData is also a dictionary object as ViewData and stores value in key/value pair. It is derived from TempDataDictionary. It is mainly used to transfer the data from one request to another request or we can say subsequent request. If the data for TempData has been read, then it will get cleaned. To persist the data, there are different ways. It all depends on how you read the data.

No Read Data

If you haven’t read the data in redirection process, then your data is available with the next subsequent request. You can see that in the following code, we have set up a TempData[“Emp” but neither read it in any action method nor in view.

So, once the “About” page renders and if we move to “Contact” page, the TempData[“Emp”] will be available.

Note

Do not read data on View.

public ActionResult Index()  
        {  
            Employee emp = new Employee() { Id = 1001, Name = "Mukesh Kumar", Address = "New Delhi", Age = 25 };  
  
            //Setting the TempData  
            TempData["Emp"] = emp;  
            return RedirectToAction("Index1");  
        }  
        public ActionResult Index1()  
        {  
            //Not reading TempData  
            return RedirectToAction("Index2");  
        }  
        public ActionResult Index2()  
        {  
            //Not reading TempData  
            return RedirectToAction("About");  
        }  
        public ActionResult About()  
        {  
//Not reading TempData  
           return View();  
        }    
       
        public ActionResult Contact()  
        {  
            //Data will available here because we have not read data yet  
            var tempEmpData = TempData["Emp"];  
            return View();  
 }  
Normal Data Read

If you read the data on “About” page when it will render and try to access the value on “Contact” page, it will not be available.

@{  
    ViewBag.Title = "About";  
}  
<h2>About Page</h2>  
<br />  
@{   
    var data = (MVCStateManagement.Models.Employee)TempData["Emp"];  
}  
TempData will not be available with Contact page because we have already read that data on “About” page. TempData is only available with subsequent request if you have not read yet.

public ActionResult Contact()  
        {  
            //Data will not available here because already read on About page  
            var tempEmpData = TempData["Emp"];  
            return View();  
 }  
Keep TempData

If you still want to persist your data with the next request after reading it on “About” page that you can use “Keep()” method after reading data on “About” page. The Keep method will persist your data for next subsequent request.

@{   
    var data = (MVCStateManagement.Models.Employee)TempData["Emp"];  
    TempData.Keep();  
}  
public ActionResult Contact()  
        {  
            //TempData will available here because we have keep on about page  
            var tempEmpData = TempData["Emp"];  
            return View();  
 }  
Peek TempData

Using Peek() method, we can directly access the TempData value and keep it for next subsequent request.

@{   
    var data = (MVCStateManagement.Models.Employee)TempData.Peek("Emp");      
}  
When we move to “Contact” page, the TempData will be available.

public ActionResult Contact()  
        {  
            //TempData will available because we have already keep data using Peek() method.  
            var tempEmpData = TempData["Emp"];  
            return View();  
 }  









Qns: 106 State Management in Web Forms
ans: 
https://www.c-sharpcorner.com/article/state-management-in-web-forms/

State management can be done either on client side or server side as explained below.

1. Introduction to Web Forms State Management

Due to the nature of the standard transfer protocol ( http ), Web pages are regenerated each time the page is posted to the server ,
because of which all information associated with the page, such as the values of controls contained within the page, would be lost 
with each round trip from the browser to the server and back. 
To overcome this inherent limitation, automatic state management facilities provided by the framework, which basically involve 
storing information either on the client or on the server, are used.

2. State Management Recommendations

What is State Management? State management is the process by which you maintain state and page information over multiple requests for 
the same or different pages.

As is true for any HTTP-based technology, Web Forms pages are stateless, which means that they do not automatically indicate whether 
the requests in a sequence are all from the same client or even whether a single browser instance is still actively viewing a page or site. 
Furthermore, pages are destroyed and recreated with each round trip to the server; therefore page information will not exist beyond the 
life cycle of a single page.

ASP.NET provides multiple ways to maintain state between server round trips. Choosing among the options for state management 
available in ASP.NET will depend heavily upon your application, and it should be based on the following criteria:

How much information do you need to store? 
Does the client accept persistent or in-memory cookies? 
Do you want to store the information on the client or server? 
Is the information sensitive? 
What sorts of performance criteria do you have for your application?
ASP.NET supports various client-side and server-side options for state management.

Client-side options are:
--------------------------------
 The View State property
 Hidden fields
 Cookies
 Query strings

Server-side options are:
--------------------------
 Application state
 Session state
 Database

a) Client-Based State Management Recommendations

The following sections describe options for state management that involve storing information either in the page or on the client computer. For these options, no information is maintained on the server between round trips.

1. View State :
---------------

The Control.ViewState property provides a dictionary object for retaining values between multiple requests for the same page. 
This is the method that the page uses to preserve page and control property values between round trips.

When the page is processed, the current state of the page and controls is hashed into a string and saved in the page as a hidden field. 
When the page is posted back to the server, the page parses the view state string at page initialization and restores property information in the page.

The advantages of using view state are:
1) No server resources required. The view state is contained in a structure within the page code.
2) Implementation is Simple.
3) Automatic retention of page and control state.
4) Enhanced security features. The values in view state are hashed, compressed, and encoded for Unicode implementations, 
  thus representing a higher state of security than hidden fields have.

The disadvantages of using the view state are:
1) Performance. Because the view state is stored in the page itself, storing large values can cause the page to slow down when users display it and when they post it.
2) Security. The view state is stored in a hidden field on the page. Although view state stores data in a hashed format, it can be tampered with. 
          The information in the hidden field can be seen if the page output source is viewed directly, creating a potential security issue.

2. Hidden Form Fields :
-----------------------

ASP.NET allows you to use HTML-standard hidden fields in a form. 
A hidden field does not render visibly in the browser, but you can set its properties just as you can with a standard control. 
When a page is submitted to the server, the content of a hidden field is sent in the HTTP Form collection along with the values of other controls. 
A hidden field acts as a repository for any page-specific information that you would like to store directly in the page.

A hidden field stores a single variable in its value property and must be explicitly added to the page. Then you insert your value into the hidden field.

ASP.NET provides the HtmlInputHidden control that offers hidden field functionality. In order for hidden field values to be available during page processing, 
you must submit the page using an HTTP post method. That is, you cannot take advantage of hidden fields if a page is processed in response to a link or 
HTTP GET method .

The advantages of using hidden fields are:

1) No server resources are required. The hidden field is stored and read from the page.
2) Broad support. Almost all browsers and client devices support forms with hidden fields.
3) Simple implementation.

The disadvantages of using hidden fields are:
1) Security. The hidden field can be tampered with. The information in the hidden field can be seen if the page output source is viewed directly, creating a 
potential security issue.

2) Limited storage structure. The hidden field does not support rich structures. Hidden fields offer a single value field in which to place information. 
To store multiple values, you must implement delimited strings and the code to parse those strings.

3) Performance. Because hidden fields are stored in the page itself, storing large values can cause the page to slow down when users display 
it and when they post it.

3. Cookies:
-----------

A cookie is a small amount of data stored either in a text file on the client's file system or in-memory in the client browser session. 
It contains page-specific information the server sends to the client along with page output. Cookies can be temporary (with specific expiration times and dates) 
or persistent. 
You can use cookies to store information about a particular client, session, or application. The cookies are saved on the client device, and when the browser 
requests a page, it sends the information in the cookie along with the request information. The server can read the cookie and extract its value. A typical 
use is to store a token (perhaps encrypted) indicating that the user has already been authenticated in your application. 
The browser can only send the data back to the server that originally created the cookie. Therefore, cookies are a relatively secure way of maintaining 
user-specific data.

The advantages of using cookies are:

1) No server resources are required. The cookie is stored on the client and read by the server after a post. 
2) Simplicity. The cookie is a lightweight, text-based structure with simple key-value pairs.
3) Configurable expiration. The cookie can expire when the browser session ends, or it can exist indefinitely on the client computer, subject to the expiration rules on the client.

The disadvantages of using cookies are:
1) Limited size. Most browsers place a 4096-byte limit on the size of a cookie, although the support for 8192-byte cookie size is becoming common in the new browser and client-device versions available today.
2) User-configured refusal. Some users disable their browser or client device's ability to receive cookies, thereby limiting this functionality.
3) Security. Cookies are subject to tampering. Users can manipulate cookies on their computer, which can potentially represent a security compromise or cause the application dependent on the cookie to fail.
4) Durability. The durability of the cookie on a client computer is subject to cookie expiration processes on the client and user intervention.

4. Query Strings:
------------------

A query string is information appended to the end of a page's URL. For example: 
http://www.contoso.com/listwidgets.aspx?category=basic&price=100

In the URL path above, the query string starts with the question mark (?) and includes two attribute-value pairs, one called "category" and the other called "price."

Query strings provide a simple but limited way of maintaining some state information. For example, they are an easy way to pass information from one page to another, 
such as passing a product number from one page to another page where it will be processed. However, most browsers and client devices impose a 255-character limit on 
the length of the URL. In addition, the query values are exposed to the Internet via the URL so in some cases security may be an issue.

In order for query string values to be available during page processing, you must submit the page using an HTTP get method. That is, you cannot take advantage of a 
query string if a page is processed in response to an HTTP post method.

The advantages of using query strings are:
---------------------------------------------
1) No server resources required. The query string is contained in the HTTP request for a specific URL.
2) Broad support. Almost all browsers and client devices support passing values in a query string.
3) Simple implementation. ASP.NET provides full support for the query string method, including methods of reading query strings using the HttpRequest.Params property.


The disadvantages of using query strings are:
---------------------------------------------
1) Security. The information in the query string is directly visible to the user via the browser user interface. The query values are exposed to the 
   Internet via the URL so in some cases security may be an issue.
2) Limited capacity. Most browsers and client devices impose a 255-character limit on URL length.






b) Server-Based State Management Recommendations

Server-side options for storing page information tend to have higher security than client-side options, but they can use more Web server resources, 
which may lead to scalability issues when the size of the information store is large. ASP.NET provides several options to implement server-side state management.
ASP.NET offers you a variety of ways to maintain state information on the server, as described in the following sections.

1. Application State:
---------------------

ASP.NET allows you to save values using application state (an instance of the HttpApplicationState class) for each active Web application. 
Application state is a global storage mechanism accessible from all pages in the Web application and is thus useful for storing information 
that needs to be maintained between server round trips and between pages.

Application state is a key-value dictionary structure created during each request to a specific URL. You can add your application-specific information 
to this structure to store it between page requests. 
Once you add your application-specific information to application state, the server manages it.

The advantages of using application state are:
1) Ease of implementation. Application state is easy to use, familiar to ASP developers, and consistent with other .NET Framework classes.
2) Global scope. Because application state is accessible to all pages in an application, storing information in application state can mean keeping only 
   a single copy of the information ( for instance, as opposed to keeping copies of information in session state or in individual pages ).

The disadvantages of using application state are:
1) Global scope. The global nature of application state can also be a disadvantage. Variables stored in application state are global only to the particular process 
   the application is running in, and each application process can have different values. Therefore, you cannot rely on application state to store unique values 
   or update global counters in Web-garden and Web-farm configurations.
2) Durability. Because global data stored in application state is volatile, it will be lost if the Web server process containing it is destroyed, most likely 
   from a server crash, upgrade, or shutdown.
3) Resource requirements. Application state requires server memory, which can affect the performance of the server as well as the scalability of the application.



2. Session State:
---------------------

ASP.NET allows you to save values using session state, which is an instance of the HttpSessionState class for each active Web application session.

Session state is similar to application state, except that it is scoped to the current browser session. If different users are using your application, each will 
have a different session state. In addition, if the same user leaves your application and then returns later, that user will also have a different session state. 
Session state is structured as a key-value dictionary structure for storing session-specific information that needs to be maintained between server round trips and 
between requests for pages. For more information, see Session State.

Session state enables you to:

Uniquely identify browser or client-device requests and map them to an individual session instance on the server.
Store session-specific data on the server for use across multiple browser or client-device requests within the same session.
Raise appropriate session management events. In addition, you can write application code leveraging these events.
Once you add your application-specific information to session state, the server manages this object. Depending on what options you specify, 
session information can be stored in cookies, an out-of-process server, or a SQL Server.

The advantages of using session state are:
1) Ease of implementation. The session state facility is easy to use, familiar to ASP developers, and consistent with other .NET Framework classes.
2) Session-specific events. Session management events can be raised and used by your application.
3) Durability. Data placed in session-state variables can survive Internet Information Services ( IIS ) restarts and worker-process restarts without 
   losing session data because the data is stored in another process space.
4) Platform scalability. Session state can be used in both multi-computer and multi-process configurations, therefore optimizing scalability scenarios.
5) Session state works with browsers that do not support HTTP cookies, although session state is most commonly used with cookies to provide user 
  identification facilities to a Web application.

The disadvantage of using session state is:
1) Performance. Session state variables stay in memory until they are either removed or replaced, and therefore can degrade server performance. 
 Session state variables containing blocks of information like large datasets can adversely affect Web server performance as server load increases.

3. Database Support:
---------------------

Maintaining state using database technology is a common practice when storing user-specific information where the information store is large. 
Database storage is particularly useful for maintaining long-term state or state that must be preserved even if the server must be restarted.

The database approach is often used in conjunction with cookies. For example, when a user first accesses your application, you might have the user log in. 
You can look up the user in your database and then pass a cookie to the user. The cookie might contain only the ID of the user in your database 
( for example, a customer number ). You can then use the cookie in subsequent requests to find the user information in the database as needed.

The database support approach enables you to:

Uniquely identify browser or client-device requests and map them to a unique ID.
Maintain state by relating stored information to the unique ID. You can use the unique ID to query the database for information relating to that ID. 
You can then modify the information and save it back to the database for use across multiple requests for the same or different pages in your site. 
Raise appropriate events. A condition in the database may determine site action. For example, if the user of a commerce site attempts to purchase 
something that is not in stock, a database query may signal that the Web site should prompt the user to make another selection.
In some cases, you may wish to use database support to maintain state on your Web site. Typically, database support is used in conjunction with 
cookies or session state. For example, it is quite common for an e-commerce Web site to maintain state information using a relational database 
for the following reasons:

Security
Personalization
Consistency
Data mining

The following are typical features of a cookie-supported database Web site:

Security:
The visitor types an account name and password into a site logon page. The site infrastructure queries the database with the logon values to determine 
if the user has rights to utilize your site. If the database validates the user information, the Web site will distribute a valid cookie containing a 
unique ID for that user on that client computer. The site grants access to the user.

Personalization:
With security information in place, your site is able to distinguish each user on your site by reading the cookie on the client computer. Typically, 
sites have information in the database that describes the preferences of a user ( identified by a unique ID ). This relationship is known as personalization. 
The site can research the user's preferences using the unique ID contained in the cookie, and then place content and information in front of the user that 
pertains to the user's specific wishes and reacts to the user's preferences over time.

Consistency:
If you have created a commerce Web site, you may wish to keep transactional records of purchases made for goods and services on your site. 
This information can be reliably saved in your database and referenced by the user's unique ID. It can be used to determine if a purchase 
transaction has been completed, and also to determine the course of action should a purchase transaction fail. The information may also be used to inform the user 
of the status of an order placed using your site.

Data mining:
Information about your site usage, your visitors, or your product transactions can be reliably stored in your database. For example, your business development 
department may wish to use this data collected from your site to determine next year's product line or distribution policy. Your marketing department may wish
to examine demographic information about users on your site. Your engineering and support department may wish to look at transactions and note areas where 
your purchasing process could be improved. Most enterprise-level relational databases such as Microsoft SQL Server contain an expansive toolset 
for most data mining projects. 
By designing the Web site to repeatedly query the database by using the unique ID during each general stage in the above scenario, the site maintains state.
In this way, the user perceives that the site is remembering and reacting to him or her personally.

The advantages of using a database to maintain state are:

1) Security. Access to databases is typically very secure, requiring rigorous authentication and authorization.
2) Capacity. You can store as much information as you like in a database.
3) Persistence. Database information can be stored as long as you like, and it is not subject to the availability of the Web server.
4) Robustness and data integrity. Databases include various facilities for maintaining good data, including triggers and referential integrity, 
   transactions, and so on. By keeping information about transactions in a database ( rather than in session state, for example ), you can recover from 
   errors more readily.
5) Accessibility. The data stored in your database is accessible to a wide variety of information-processing tools.
6) Wide support. There is a large range of database tools available, and many custom configurations are available.

The disadvantages of using a database to maintain state are:
1) Complexity. Using a database to support state management implies more complex hardware and software configurations.
2) Performance. Poor construction of the relational data model can lead to scaling issues. Also, leveraging too many queries to the database
   can adversely affect server performance.






Qns 107: Session-State Modes
ans: https://msdn.microsoft.com/en-us/library/ms178586.aspx
https://www.codeproject.com/Articles/32545/Exploring-Session-in-ASP-Net

ASP.NET session state supports several different storage options for session data. 
Each option is identified by a value in the SessionStateMode enumeration. The following list describes the available session state modes:

1) InProc mode, which stores session state in memory on the Web server. This is the default.

2) StateServer mode, which stores session state in a separate process called the ASP.NET state service. 
   This ensures that session state is preserved if the Web application is restarted and also makes session 
   state available to multiple Web servers in a Web farm.

3) SQLServer mode stores session state in a SQL Server database. 
   This ensures that session state is preserved if the Web application is restarted and also makes session 
   state available to multiple Web servers in a Web farm.

4) Custom mode, which enables you to specify a custom storage provider.

5) Off mode, which disables session state.



Qns 108: unit testing tool
ans: Microsoft.VisualStudio.TestTools.UnitTesting;

example:

    [TestClass]
    public class CanonUnitTest
    {
             
        [TestMethod]
        public void TestCanonInitializationSequenceCommands ()
        {
            CanonConnectCommands ();

            // check for lens connection if not connected run the function again after some delay
            if (!(_receiver.LensState == LensModeEnum.Connected)) {
                CanonConnectCommands ();
            }
        }
     }




qns 109: How to find the missing number in integer array of 1 to 100?
ans: sum all the numbers and subtract it from expected result gives you the missing number


qns 110: merge two un-sorted array to single sorted array, also does not contain duplicate?
ans: 

// Function to merge array in sorted order

        public static int[] SortedMerge (int[] a, int[] b)
        {                     
            Dictionary<int, int> dist = new Dictionary<int, int> ();
            int i = 0, j = 0, k = 0;
            while (i < a.Length) {
                if (!dist.ContainsKey (a[i])) {
                    dist[a[i]] = a[i];
                }
                i++;
            }
            while (j < b.Length) {
                if (!dist.ContainsKey (b[j])) {
                    dist[b[j]] = b[j];
                }
                j++;
            }

            int[] resArr = new int[dist.Count];

            foreach (var item in dist) {
                resArr[k] = Convert.ToInt32 (item.Value);
                k++;
            }
            //{4,1,3,2} {1,2,3,4}

            for (int outer = 0; outer < resArr.Length; outer++) {

                for (int inner = outer + 1; inner < resArr.Length; inner++) {

                    // check for ascending order
                    if (resArr[outer] > resArr[inner]) {
                        //// swap
                        //int temp = resArr[inner];
                        //resArr[inner] = resArr[outer];
                        //resArr[outer] = temp;

                        //// or
                        //resArr[inner] = resArr[inner] + resArr[outer];
                        //resArr[outer] = resArr[inner] - resArr[outer];
                        //resArr[inner] = resArr[inner] - resArr[outer];

                        // or
                        resArr[inner] = resArr[inner] * resArr[outer];
                        resArr[outer] = resArr[inner] / resArr[outer];
                        resArr[inner] = resArr[inner] / resArr[outer];
                    }
                }
            }

            return resArr;

        }

or
   public static int[] SortedMerge (int[] a, int[] b)
   { 
  
            int totalSize = a.Length + b.Length;
            int dulpicateNumbersCount = 0;
            int[] resultArray = new int[totalSize];
            int i = 0, j = 0, k = 0;
            while (i < a.Length) {
                if (!resultArray.Contains (a[i])) {
                    resultArray[k] = a[i];
                    k++;
                } else {
                    dulpicateNumbersCount++;
                }
                i++;
            }
            while (j < b.Length) {
                if (!resultArray.Contains (b[j])) {
                    resultArray[k] = b[j];
                    k++;
                } else {
                    dulpicateNumbersCount++;
                }
                j++;
            }

            Array.Resize (ref resultArray, totalSize - dulpicateNumbersCount);

            //{4,1,3,2} {1,2,3,4}

            for (int outer = 0; outer < resultArray.Length; outer++) {

                for (int inner = outer + 1; inner < resultArray.Length; inner++) {

                    // check for ascending order
                    if (resultArray[outer] > resultArray[inner]) {
                        //// swap
                        //int temp = resultArray[inner];
                        //resultArray[inner] = resultArray[outer];
                        //resultArray[outer] = temp;

                        //// or
                        //resultArray[inner] = resultArray[inner] + resultArray[outer];
                        //resultArray[outer] = resultArray[inner] - resultArray[outer];
                        //resultArray[inner] = resultArray[inner] - resultArray[outer];

                        // or
                        resultArray[inner] = resultArray[inner] * resultArray[outer];
                        resultArray[outer] = resultArray[inner] / resultArray[outer];
                        resultArray[inner] = resultArray[inner] / resultArray[outer];
                    }
                }
            }

            return resultArray;
}


qns 111: write a program to reverse the number ex input =1234 and output would be 4321?
ans: 
   class Program  
    {  
        static void Main(string[] args)  
        {  
            Console.WriteLine("Enter a No. to reverse");  
            int Number = int.Parse(Console.ReadLine());  
            int Reverse = 0;  
            while(Number>0)  
            {  
                int remainder = Number % 10;  
                Reverse = (Reverse * 10) + remainder;  
                Number = Number / 10;  
            }  
            Console.WriteLine("Reverse No. is {0}",Reverse);  
            Console.ReadLine();  
        }  
    }  


qns 112: write a program to send message to 100000 user at same time?
ans: 

qns 113: how to handle the situation if multiple user access your api at the same time?
ans: 


qns 114: difference between dependency injection and Dependency inversion principle?
ans:  
https://www.codeproject.com/Articles/495019/Dependency-Inversion-Principle-and-the-Dependency

The Dependency Inversion principle (DIP) helps to loosely couple your code by ensuring that 
your high-level modules depend on abstractions rather than concrete implementations of lower-level modules. 
The Dependency Injection pattern is an application/ implementation of this principle



Qns: 115 what is socket in web api ?
Ans: 

Image result for use of socket in web api
WebSockets is a message based protocol that takes advantage of a TCP streamed connection. 
The System.Net.WebSockets namespace provides support for working with web sockets in .Net.

WebSocket is a computer communications protocol, providing full-duplex communication channels over a single TCP connection

A web socket is a TCP socket connection between the client and the server over a network. 
Essentially, a web socket is a two-way full duplex communication between the client and the server over a network.

WebSockets implement fast, secure, bi-directional, full duplex communication between a client and a server 
to support real-time, low-latency messaging

WebSockets is a message based protocol that takes advantage of a TCP streamed connection. 
The System.Net.WebSockets namespace provides support for working with web sockets in .Net. 

Note that a web socket connection between a server and a client application is established through a 
HTTP handshake exchange between them.

WebSocket - is a web-based technology that provides full-duplex communication channels over a single TCP connection

WebSocket protocol can be used in any client-server applications. It should be noted that the WebSocket protocol has nothing 
to do with the HTTP protocol. The only thing that the HTTP protocol is used to verify that the parties support the WebSocket protocol. 
If WebSockets is confirmed by both parties, then the entire subsequent data exchange process takes place without the use of HTTP. 
Naturally, if one of the parties (usually those are web browsers) requests this information, 
it means that it already supports WebSocket. To set up a connection and go to the WebSocket protocol, the client, in this case, 
the browser, sends approximately this request:


The idea behind the WebSocket protocol consists of reusing the established TCP connection between a Client and Server. 
After the HTTP handshake the Client and Server

https://code.msdn.microsoft.com/The-simple-WebSocket-4524921c
http://www.msdr.ru/28/
http://www.msdr.ru/33/
http://www.msdr.ru/34/
https://code.msdn.microsoft.com/The-simple-WebSocket-0dd65479

Note:
HTTP also works over TCP. So the first step done by the client in initiating a http connection is 
establishing a TCP connection with the http server.

Web Sockets and Web API are two entirely different concepts.
---------------------------------------------------------------
Web API is a type of Web Services which handles HTTP requests and will be something that you actually make your request to 
when you need to access your data (or make changes to it). 

Web Sockets are a type of connection that can be used within browsers to create a persistent connection between the client and server. 
This can be used for a wide variety of things such as handling various real-time activities (like chat, notifications, etc.)
but I don't believe that it would provide any benefit with regards to accessing your data quicker.

You can read more about Web Sockets here or a related technology like SignalR here 
(it uses web sockets and other related technologies to maintain real-time connectivity).


advantage:
1) Web Socket is a stateful protocol whereas HTTP is a stateless protocol.
2) The key points of Web Sockets are true concurrency and optimization of performance, 
   resulting in more responsive and rich web applications.



Qns: 116 diff between http(request/response) and web socket
ans:  https://developerinsider.co/difference-between-http-and-http-2-0-websocket/
WebSocket is a protocol providing full-duplex communication channels over a single TCP connection. 
Where as, HTTP providing half-duplex communication.


Information exchange mode of WebSocket is bidirectional. Means, 
server can push information to the client (which does not allow direct HTTP).




Qns 117, key ponints turns into your mind when designing an web api, what is general response model from an api?
ans: 
use http vers as by convention
token authentication
use Design Patterns and SOLID principles 


qns 119: at what time garbage collector get called and its generation?
ans:

Generations
---------------
The heap is organized into generations so it can handle long-lived and short-lived objects. 
Garbage collection primarily occurs with the reclamation of short-lived objects that typically 
occupy only a small part of the heap. There are three generations of objects on the heap:

Generation 0. 
This is the youngest generation and contains short-lived objects. 
An example of a short-lived object is a temporary variable. 
Garbage collection occurs most frequently in this generation.

Newly allocated objects form a new generation of objects and are implicitly generation 0 collections,
unless they are large objects, in which case they go on the large object heap in a generation 2 collection.

Most objects are reclaimed for garbage collection in generation 0 and do not survive to the next generation.

Generation 1. 
This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.

Generation 2. 
This generation contains long-lived objects. An example of a long-lived object is an object in a server application that contains 
static data that is live for the duration of the process.


https://stackoverflow.com/questions/2257563/what-are-the-generations-in-garbage-collection

Generations

A generational garbage collector collects the short-lived objects more frequently than the longer lived ones. 
Short-lived objects are stored in the first generation, generation 0. The longer-lived objects are pushed into the higher generations,
1 or 2. 

The garbage collector works more frequently in the lower generations than in the higher ones.

When an object is first created, it is put into generation 0. When the generation 0 is filled up, the garbage collector is invoked. 
The objects that survive the garbage collection in the first generation are promoted onto the next higher generation, generation 1. 
The objects that survive garbage collection in generation 1 are promoted onto the next and the highest generation, generation 2. 
This algorithm works efficiently for garbage collection of objects, as it is fast. 
Note that generation 2 is the highest generation that is supported by the garbage collector.


Qns 120: what is mocking ?
ans: In simple English, Mocking is make a replica or imitation of something. 
     We use mocking in unit testing. A object that you want to test may have dependencies on other complex objects. ... 
     So in simple words, mocking is creating objects that simulate the behavior of real objects.

    unit testing tool:  Microsoft.VisualStudio.TestTools.UnitTesting

Qns 121: difference between static class and singleton class ?
ans:  

  Static Class:-
-------------------------
1) You cannot create the instance of static class.
2) Loaded automatically by the .NET Framework common language runtime (CLR) when the program or namespace containing the class is loaded.
3) Static Class cannot have constructor.
4) We cannot pass the static class to method.
5) We cannot inherit Static class to another Static class in C#.
6) A class having all static methods.
7) Better performance (static methods are bonded on compile time)

  Singleton:-
------------------
1) You can create one instance of the object and reuse it.
2) Singleton instance is created for the first time when the user requested.
3) Singleton class can have constructor.
4) You can create the object of singleton class and pass it to method.
5) Singleton class does not say any restriction of Inheritance.
6) We can dispose the objects of a singleton class but not of static class.
7) Methods can be overridden.
8) Can be lazy loaded when need (static classes are always loaded).
9) We can implement interface(static class can not implement interface).

example:
 We can implement an interface with a Singleton class, but we can't implement an interface with a static class

    error: can not declare instance member in static class
    static class MyClass : IDisposable
    {
        public void Dispose ()
        {
            throw new NotImplementedException ();
        }
    }




Qns 122: static variable stored in heap or stack in c#
ans: Static variables are stored on the Managed Heap, not the Stack, when the type is first referenced.  

Qns 123: difference between events and delagates?


